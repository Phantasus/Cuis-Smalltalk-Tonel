Object subclass: #STON	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Facade'!!STON commentStamp: '' prior: 0!STON implements serialization and materialization using the Smalltalk Object Notation format.I am a class side facade offering a high level API to write and read objects using STON.U s a g eBasic operations  #toString:  #fromString:  STON toString: DisplayScreen boundingBox.  STON fromString:  'Rectangle{#origin:Point[0,0],#corner:Point[1920,1030]}'.  STON toString: { DateAndTime now. Float pi. 1 to: 10 by: 2. 3 days }.  STON fromString:  '[DateAndTime[''2016-03-15T13:57:59.462422+01:00''],3.141592653589793,Interval{#start:1,#stop:10,#step:2},Duration{#nanos:0,#seconds:259200}]'You can also read from or write to streams  #fromStream:  #put:onStream:There is also the option to do pretty printing (indenting, multi line output)   #toStringPretty:  #put:onStreamPretty:STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using #fromString: or #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using:   #toJsonString[Pretty]:  #put:asJsonOnStream[Pretty]:Note that you can only write Arrays and Dictionaries !!For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.Like JSON, STON does not allow for comments. However, a preprocessor option can skip C style comments before parsing.I also define some contants used in the implementation: the class used as list, map and association, as well as the optional class name key (used when reading objects using an unknown class).I m p l e m e n t a t i o nThe 2 key methods are  #stonOn:  #fromSton:which work together with STONWriter and STONReader; read their class comments for all configuration options (you can use the #reader and #writer methods to avoid referring to these classes directly).Several methods are used to support and/or control the implementation  #stonName - defines the external name for a class  #stonAllInstVarNames - defines which instance variable to write  #stonContainSubObjects - shortcut looking into objects for subobjects  #stonShouldWriteNilInstVars - option to skip writing nil valued instance variablesS y n t a x	value	  primitive-value	  object-value	  reference	  nil	primitive-value	  number	  true	  false	  symbol	  string	object-value	  object	  map	  list	object	  classname map	  classname list	reference	  @ int-index-previous-object-value	map	  {}	  { members }	members	  pair	  pair , members	pair	  string : value	  symbol : value	  number : value	list	  []	  [ elements ]	elements	  value 	  value , elements	string	  ''	  ' chars '	chars	  char	  char chars	char	  any-printable-ASCII-character-	    except-'-"-or-\	  \'	  \"	  \\	  \/	  \b	  \f	  \n	  \r	  \t	  \u four-hex-digits	symbol	  # chars-limited	  # ' chars '	chars-limited	  char-limited	  char-limited chars-limited	char-limited	  a-z A-Z 0-9 - _ . /	classname	  uppercase-alpha-char alphanumeric-char	number	  int	  int denominator	  int denominator scale	  int frac	  int exp	  int frac exp	int	  digit	  digit1-9 digits 	  - digit	  - digit1-9 digits	denominator	  / digits	scale	  s digits	frac	  . digits	exp	  e digits	digits	  digit	  digit digits	e	  e	  e+	  e-	  E	  E+	  E-!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STON class	instanceVariableNames: ''!!STON class methodsFor: 'accessing'!jsonWriter	^ STONWriter new			jsonMode: true;			referencePolicy: #error;			yourself! !!STON class methodsFor: 'accessing'!associationClass	^ Association! !!STON class methodsFor: 'accessing'!mapClass	^ Dictionary! !!STON class methodsFor: 'accessing'!classNameKey	^ #className! !!STON class methodsFor: 'accessing'!listClass	^ Array! !!STON class methodsFor: 'accessing'!writer	^ STONWriter new! !!STON class methodsFor: 'accessing'!reader	^ STONReader new! !!STON class methodsFor: 'convencience'!toString: object	^ String streamContents: [ :stream |		self put: object onStream: stream ]! !!STON class methodsFor: 'convencience'!toStringPretty: object	^ String streamContents: [ :stream |		self put: object onStreamPretty: stream ]! !!STON class methodsFor: 'convencience'!put: object onStream: stream	(self writer on: stream) nextPut: object! !!STON class methodsFor: 'convencience'!toJsonStringPretty: object	^ String streamContents: [ :stream |		self put: object asJsonOnStreamPretty: stream ]! !!STON class methodsFor: 'convencience'!fromStreamWithComments: readStream	^ (self reader on: (STONCStyleCommentsSkipStream on: readStream)) next! !!STON class methodsFor: 'convencience'!toJsonString: object	^ String streamContents: [ :stream |		self put: object asJsonOnStream: stream ]! !!STON class methodsFor: 'convencience'!fromString: string	^ self fromStream: string readStream! !!STON class methodsFor: 'convencience'!put: object asJsonOnStream: stream	(self jsonWriter on: stream) nextPut: object! !!STON class methodsFor: 'convencience'!put: object asJsonOnStreamPretty: stream	(self jsonWriter on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'convencience'!put: object onStreamPretty: stream	(self writer on: stream)		prettyPrint: true; 		nextPut: object! !!STON class methodsFor: 'convencience'!fromStringWithComments: string	^ self fromStreamWithComments: string readStream! !!STON class methodsFor: 'convencience'!fromStream: readStream	^ (self reader on: readStream) next! !Object subclass: #STONJSON	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Facade'!!STONJSON commentStamp: '' prior: 0!I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.STON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are   - class information (except for lists (Array) and maps (Dictionary))  - proper handling of shared and circular references  - more Smalltalk like syntax (Symbols with #, single qouted Strings, nil instead of null)  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)Parsing JSON is done using  #fromString:  #fromStream: with the results being composed of Arrays and Dictionaries.Writing objects as JSON is done using  #toString[Pretty]:  #put:onStream[Pretty]:Note that you can only write Arrays and Dictionaries !! Shared and circular references will be noted and signalled using an exception.E x a m p l e s  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.  STONJSON fromString: '[1,-1,3.141592653589793,true,"JSON"]'.  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.  STONJSON fromString: '{"foo":1,"bar":2,"sub":{"a":true,"b":false},"flags":[1,8,32]}'. For a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONJSON class	instanceVariableNames: ''!!STONJSON class methodsFor: 'convenience'!toString: object	^ STON toJsonString: object! !!STONJSON class methodsFor: 'convenience'!fromStream: stream	^ STON fromStream: stream! !!STONJSON class methodsFor: 'convenience'!toStringPretty: object	^ STON toJsonStringPretty: object! !!STONJSON class methodsFor: 'convenience'!put: object onStream: stream	STON put: object asJsonOnStream: stream! !!STONJSON class methodsFor: 'convenience'!put: object onStreamPretty: stream	STON put: object asJsonOnStreamPretty: stream! !!STONJSON class methodsFor: 'convenience'!fromString: string	^ STON fromString: string! !Object subclass: #STONStreamWriter	instanceVariableNames: 'writer first'	classVariableNames: ''	package: 'STON-Core-Writer'!!STONStreamWriter commentStamp: '' prior: 0!STONStreamWriter helps in streaming writing STON representations.This is an abstract class.!!STONStreamWriter methodsFor: 'initialize-release'!on: stonWriter	writer := stonWriter! !!STONStreamWriter methodsFor: 'initialize-release'!initialize	super initialize.	first := true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONStreamWriter class	instanceVariableNames: ''!!STONStreamWriter class methodsFor: 'instance creation'!on: stonWriter	^ self new		on: stonWriter;		yourself! !STONStreamWriter subclass: #STONListWriter	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Writer'!!STONListWriter commentStamp: '' prior: 0!STONArrayWriter helps in writing array based STON representations.!!STONListWriter methodsFor: 'accessing'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer listElementSeparator ].	writer nextPut: anObject! !STONStreamWriter subclass: #STONMapWriter	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Writer'!!STONMapWriter commentStamp: '' prior: 0!STONDictionaryWriter helps in writing dictionary based STON representations.!!STONMapWriter methodsFor: 'accessing'!at: key put: value	first ifTrue: [ first := false ] ifFalse: [ writer mapElementSeparator ].	writer encodeKey: key value: value! !STONListWriter subclass: #STONShortListWriter	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Writer'!!STONShortListWriter commentStamp: '' prior: 0!STONShortArrayWriter helps in writing short array based STON representations.!!STONShortListWriter methodsFor: 'accessing'!add: anObject	first ifTrue: [ first := false ] ifFalse: [ writer shortListElementSeparator ].	writer nextPut: anObject! !Object subclass: #STONWriter	instanceVariableNames: 'writeStream prettyPrint stonCharacters newLine asciiOnly jsonMode keepNewLines referencePolicy level objects'	classVariableNames: 'STONCharacters STONSimpleSymbolCharacters'	package: 'STON-Core-Writer'!!STONWriter commentStamp: '' prior: 0!STONWriter serializes objects using the Smalltalk Object Notation format. Customization options are:- prettyPrint <Boolean> default is false	if true, produce pretty printed output- newLine <String> default is String cr	what sequence to use for EOL- asciiOnly <Boolean> default is false   if true, use \u escapes for all non-ASCII characters   most common control characters are still escaped- jsonMode <Boolean> default is false	if true, the follow changes occur	- strings are delimited with double quotes	- nil is encoded as null	- symbols are treated as strings	- only STON listClass and STON mapClass instances are allowed as composite objects	it is wise to also use either #error or #ignore as referencePolicy to avoid references- referencePolicy <#normal|#ignore|#error> default is #normal	if #normal, track and count object references and use references to implement sharing and break cycles	if #error, track object references and signal STONWriterError when a shared reference is encountered	if #ignore, don't track object references which might loop forever on cycles - keepNewLines <Boolean> default is false	if true, any newline sequence CR, LF or CRLF inside strings or symbols will not be escaped 	but will be written as the newline EOF convention	Note that in default STON mode I only use the following named character escapes: \b \t \n \f \' and \\ while in JSON mode \' is replaced by \"!!STONWriter methodsFor: 'writing'!writeBoolean: boolean	writeStream print: boolean! !!STONWriter methodsFor: 'writing'!encodeMap: pairs	| first |	first := true.	writeStream nextPut: ${.	pairs isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				pairs keysAndValuesDo: [ :key :value |					first 						ifTrue: [ first := false ] 						ifFalse: [ self mapElementSeparator ].					self encodeKey: key value: value ] ].			self newlineIndent ].	writeStream nextPut: $}! !!STONWriter methodsFor: 'writing'!writeReference: index	writeStream		nextPut: $@;		print: index! !!STONWriter methodsFor: 'writing'!writeFraction: fraction	jsonMode		ifTrue: [ self writeFloat: fraction asFloat ]		ifFalse: [ writeStream				print: fraction numerator;				nextPut: $/;				print: fraction denominator ]! !!STONWriter methodsFor: 'writing'!writeNull	jsonMode		ifTrue: [ writeStream nextPutAll: 'null' ]		ifFalse: [ writeStream print: nil ]! !!STONWriter methodsFor: 'writing'!writeFloat: float	writeStream print: float! !!STONWriter methodsFor: 'writing'!writeObject: object streamList: block	self writeObject: object do: [ | listWriter |		listWriter := STONListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self newlineIndent.			block value: listWriter ].		self newlineIndent.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing'!writeMap: hashedCollection	self with: hashedCollection do: [ 		self encodeMap: hashedCollection ]! !!STONWriter methodsFor: 'writing'!writeObject: object streamMap: block	self writeObject: object do: [ | mapWriter |		mapWriter := STONMapWriter on: self.		writeStream nextPut: ${.		self indentedDo: [			self newlineIndent.			block value: mapWriter ].		self newlineIndent.		writeStream nextPut: $} ]! !!STONWriter methodsFor: 'writing'!writeScaledDecimal: scaledDecimal	jsonMode		ifTrue: [ self writeFloat: scaledDecimal asFloat ]		ifFalse: [ writeStream				print: scaledDecimal numerator;				nextPut: $/;				print: scaledDecimal denominator;				nextPut: $s;				print: scaledDecimal scale ]! !!STONWriter methodsFor: 'writing'!writeObject: anObject named: stonName do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		writeStream nextPutAll: stonName.		self prettyPrintSpace.		block value ]! !!STONWriter methodsFor: 'writing'!writeSymbol: symbol	jsonMode		ifTrue: [			self writeString: symbol ]		ifFalse: [			writeStream nextPut: $#.			(self isSimpleSymbol: symbol)				ifTrue: [					writeStream nextPutAll: symbol ]				ifFalse: [					self encodeString: symbol ] ]! !!STONWriter methodsFor: 'writing'!encodeList: elements	writeStream nextPut: $[.	elements isEmpty		ifTrue: [			self prettyPrintSpace ]		ifFalse: [			self indentedDo: [				self newlineIndent.				elements 					do: [ :each | self nextPut: each ]					separatedBy: [ self listElementSeparator ] ].			self newlineIndent ].	writeStream nextPut: $]! !!STONWriter methodsFor: 'writing'!writeObject: object named: stonName listSingleton: element	self writeObject: object named: stonName do: [		writeStream nextPut: $[.		self 			prettyPrintSpace;			nextPut: element;			prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing'!writeInteger: integer	writeStream print: integer! !!STONWriter methodsFor: 'writing'!writeList: collection	self with: collection do: [ 		self encodeList: collection ]! !!STONWriter methodsFor: 'writing'!writeAssociation: association	jsonMode		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self 		encodeKey: association key 		value: association value! !!STONWriter methodsFor: 'writing'!writeObject: object streamShortList: block	self writeObject: object do: [ | listWriter |		listWriter := STONShortListWriter on: self.		writeStream nextPut: $[.		self indentedDo: [			self prettyPrintSpace.			block value: listWriter ].		self prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'writing'!writeObject: anObject	| instanceVariableNames |	(instanceVariableNames := anObject class stonAllInstVarNames) isEmpty		ifTrue: [ 			self writeObject: anObject do: [ self encodeMap: #() ] ]		ifFalse: [ 			self writeObject: anObject streamMap: [ :dictionary | 				instanceVariableNames do: [ :each | 					(anObject instVarNamed: each)						ifNotNil: [ :value | 							dictionary at: each asSymbol put: value ]						ifNil: [ 							anObject stonShouldWriteNilInstVars 								ifTrue: [ dictionary at: each asSymbol put: nil ] ] ] ] ]! !!STONWriter methodsFor: 'writing'!writeString: string	self encodeString: string! !!STONWriter methodsFor: 'writing'!writeObject: anObject do: block	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])		ifTrue: [ self error: 'wrong object class for JSON mode' ].	self with: anObject do: [		writeStream nextPutAll: anObject class stonName.		self prettyPrintSpace.		block value ]! !!STONWriter methodsFor: 'writing'!writeObject: object listSingleton: element	self writeObject: object do: [		writeStream nextPut: $[.		self 			prettyPrintSpace;			nextPut: element;			prettyPrintSpace.		writeStream nextPut: $] ]! !!STONWriter methodsFor: 'error handling'!error: aString	^ STONWriterError signal: aString! !!STONWriter methodsFor: 'private'!shortListElementSeparator	writeStream nextPut: $,.	self prettyPrintSpace! !!STONWriter methodsFor: 'private'!with: object do: block	| index |	referencePolicy = #ignore 		ifTrue: [ ^ block value ].	(index := objects at: object ifAbsent: [ nil ]) notNil		ifTrue: [			referencePolicy = #error				ifTrue: [ ^ self error: 'shared reference detected' ].			self writeReference: index ]		ifFalse: [			index := objects size + 1.			objects at: object put: index.			block value ]! !!STONWriter methodsFor: 'private'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'private'!encodeKey: key value: value	(jsonMode and: [ key isString not ])		ifTrue: [ self error: 'JSON key names in objects must be strings' ].	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!STONWriter methodsFor: 'private'!encodeString: string	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ]).	keepNewLines		ifTrue: [ 			self encodeStringKeepingNewLines: string ]		ifFalse: [ 			string do: [ :each | self encodeCharacter: each ] ].	writeStream nextPut: (jsonMode ifTrue: [ $" ] ifFalse: [ $' ])! !!STONWriter methodsFor: 'private'!encodeCharacter: char	| code encoding |	"STONCharacters contains for the lower 127 characters (codes 0 to 126) either nil (unknown), 	#pass (output as is, clean ASCII characters) or a full escape string"	((code := char codePoint) < 127 and: [ (encoding := self stonCharacters at: code + 1) notNil ])		ifTrue: [ 			(encoding = #pass or: [ jsonMode and: [ char = $' ] ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ writeStream nextPutAll: encoding ] ]		ifFalse: [			"always escape Latin1 C1 controls, or when asciiOnly is true" 			(code > 16r9F and: [ asciiOnly not ])				ifTrue: [ writeStream nextPut: char ]				ifFalse: [ self escapeUnicode: code ] ]! !!STONWriter methodsFor: 'private'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!STONWriter methodsFor: 'private'!stonCharacters	^ stonCharacters ifNil: [ stonCharacters := STONCharacters ]! !!STONWriter methodsFor: 'private'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!STONWriter methodsFor: 'private'!encodeStringKeepingNewLines: string	| input char |	input := string readStream.	[ input atEnd ]		whileFalse: [ 			char := input next.			char = Character lf				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr						ifTrue: [ 							input peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ self encodeCharacter: char ] ] ]! !!STONWriter methodsFor: 'private'!prettyPrintSpace	prettyPrint ifTrue: [ writeStream space ]! !!STONWriter methodsFor: 'private'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!STONWriter methodsFor: 'private'!newlineIndent	prettyPrint ifTrue: [ 		writeStream nextPutAll: newLine.		level timesRepeat: [ writeStream tab ] ]! !!STONWriter methodsFor: 'private'!writeableStonCharacters	^ self stonCharacters == STONCharacters		ifTrue: [ stonCharacters := stonCharacters copy ]		ifFalse: [ stonCharacters ]! !!STONWriter methodsFor: 'private'!isSimpleSymbol: symbol	(symbol isEmpty or: [ symbol isWideString ]) 		ifTrue: [ ^ false ].	^ (symbol class 		findFirstInString: symbol 		inSet: STONSimpleSymbolCharacters 		startingAt: 1) = 0! !!STONWriter methodsFor: 'private'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!STONWriter methodsFor: 'initialize-release'!prettyPrint: boolean	prettyPrint := boolean! !!STONWriter methodsFor: 'initialize-release'!escape: char with: anObject	"Instruct me to escape char with object, either a replacement string or #pass"		"self escape: $/ with: '\/'."		self assert: (anObject isString | (anObject == #pass)).	self assert: char isOctetCharacter.	self writeableStonCharacters at: char codePoint + 1 put: anObject! !!STONWriter methodsFor: 'initialize-release'!asciiOnly: boolean	asciiOnly := boolean! !!STONWriter methodsFor: 'initialize-release'!newLine: string	"The sequence to use when ending a line, either CR, LF or CRLF"		newLine := string! !!STONWriter methodsFor: 'initialize-release'!reset	objects removeAll! !!STONWriter methodsFor: 'initialize-release'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ].! !!STONWriter methodsFor: 'initialize-release'!initialize	super initialize.	stonCharacters := STONCharacters.	prettyPrint := false.	newLine := String cr.	level := 0.	referencePolicy := #normal.	jsonMode := keepNewLines := asciiOnly := false.	objects := IdentityDictionary new! !!STONWriter methodsFor: 'initialize-release'!on: aWriteStream	writeStream := aWriteStream! !!STONWriter methodsFor: 'initialize-release'!keepNewLines: boolean	"If true, any newline CR, LF or CRLF inside strings or symbols will not be escaped	but will instead be converted to the newline convention chosen, see #newLine:	The default is false, where CR, LF or CRLF will be enscaped unchanged."		keepNewLines := boolean! !!STONWriter methodsFor: 'initialize-release'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!STONWriter methodsFor: 'initialize-release'!referencePolicy: policy	self assert: ( #(#normal #ignore #error) includes: policy ).	referencePolicy := policy! !!STONWriter methodsFor: 'initialize-release'!jsonMode: boolean	(jsonMode := boolean)		ifTrue: [ 			self				escape: $' with: #pass;				escape: $" with: '\"' ]		ifFalse: [ 			self				escape: $" with: #pass;				escape: $' with: '\''' ]! !!STONWriter methodsFor: 'public'!nextPut: anObject	anObject stonOn: self! !!STONWriter methodsFor: 'accessing'!jsonMode	^ jsonMode ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONWriter class	instanceVariableNames: ''!!STONWriter class methodsFor: 'private'!isSimpleSymbolChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./' includes: char! !!STONWriter class methodsFor: 'class initialization'!initializeSTONCharacters	| escapes |	STONCharacters := Array new: 127.	32 to: 126 do: [ :each | 		STONCharacters at: each + 1 put: #pass ].	"This is the minimal STON set of named escapes"	escapes := #( 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 39 '\''' 92 '\\' ).	escapes pairsDo: [ :code :escape | 		STONCharacters at: code + 1 put: escape ]! !!STONWriter class methodsFor: 'class initialization'!initializeSTONSimpleSymbolCharacters	"STONSimpleSymbolCharacters asArray collectWithIndex: [ :each :index |		each isZero ifTrue: [ (index - 1) asCharacter ] ]."			STONSimpleSymbolCharacters := ByteArray new: 256 withAll: 1.	1 to: 256 do: [ :each | | char |		char := (each - 1) asCharacter.		(self isSimpleSymbolChar: char)			ifTrue: [ 				STONSimpleSymbolCharacters at: each put: 0 ] ]! !!STONWriter class methodsFor: 'class initialization'!initialize	"Modification timestamp 20170131"		self initializeSTONCharacters.	self initializeSTONSimpleSymbolCharacters! !!STONWriter class methodsFor: 'instance creation'!on: writeStream	^ self new		on: writeStream;		yourself! !Error subclass: #STONWriterError	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Writer'!!STONWriterError commentStamp: '' prior: 0!STONWriterError is the error/exception signalled by STONWriter when illegal/incorrect input is seen. !STONWriter initialize!Object subclass: #STONCStyleCommentsSkipStream	instanceVariableNames: 'stream peekedCharacter delimiter escape'	classVariableNames: ''	package: 'STON-Core-Reader'!!STONCStyleCommentsSkipStream commentStamp: '' prior: 0!I am STONCStyleCommentsSkipStream, a character ReadStream wrapping another character ReadStream. I skip C style comments, much like a classic C preprocessor.C, C++, Java, JavaScript style comments are either the multiline	/* a comment */	or the single line, up to end of line	// a comment 	I deal with any end of line convention. Multiline comments cannot be nested. You create me #on: another character ReadStream. Here is an example:	(STONCStyleCommentsSkipStream on: 'abc/*comment*/def' readStream) upToEnd.	Comments inside single and double quote delimited strings are ignored. Backslash escapes for single and double quotes inside strings are honored.!!STONCStyleCommentsSkipStream methodsFor: 'testing'!atEnd	^ self peek isNil! !!STONCStyleCommentsSkipStream methodsFor: 'testing'!isBinary	^ false! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release'!close	stream close! !!STONCStyleCommentsSkipStream methodsFor: 'initialize-release'!on: readStream	stream := readStream! !!STONCStyleCommentsSkipStream methodsFor: 'private'!nextNonCommentChar	| char |	char := stream next.	(self insideString and: [ char = $\ ])		ifTrue: [ 			escape := true. 			^ char ].	(char = $') | (char = $")		ifTrue: [ 			^ self handleStringDelimiter: char ].	escape := false. 	^ (char = $/ and: [ self insideString not and: [ (stream peek = $/) | (stream peek = $*) ] ])		ifTrue: [ 			self consumeComment.			stream next ]		ifFalse: [ char ]! !!STONCStyleCommentsSkipStream methodsFor: 'private'!consumeToCommentEnd	[ stream atEnd or: [ stream next = $* and: [ stream peekFor: $/ ] ] ] whileFalse! !!STONCStyleCommentsSkipStream methodsFor: 'private'!handleStringDelimiter: char	self escape		ifTrue: [ escape := false ]		ifFalse: [ 			self insideString				ifTrue: [ 					char = delimiter						ifTrue: [ delimiter := nil ] ]				ifFalse: [ delimiter := char ] ].	^ char! !!STONCStyleCommentsSkipStream methodsFor: 'private'!consumeComment	stream peek = $/ ifTrue: [ self consumeToEOL ].	stream peek = $* ifTrue: [ self consumeToCommentEnd ]! !!STONCStyleCommentsSkipStream methodsFor: 'private'!insideString	"Return true when we are currently inside a string where comments should be ignored."		^ (delimiter = $') | (delimiter = $")! !!STONCStyleCommentsSkipStream methodsFor: 'private'!escape	"Return true when we previously read a backslash escape inside a string, 	so that the next string delimiter should be returned as is"		^ escape = true! !!STONCStyleCommentsSkipStream methodsFor: 'private'!consumeToEOL	| eol char |	eol := false.	[ eol ] whileFalse: [ 		char := stream next.		(char isNil or: [ char = Character lf ])			ifTrue: [ eol := true ]			ifFalse: [ 				char = Character cr					ifTrue: [ 						eol := true.						stream peekFor: Character lf ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!collectionSpecies	^ String! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!peek	^ peekedCharacter		ifNil: [			stream atEnd				ifFalse: [ 					peekedCharacter := self nextNonCommentChar ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!position	^ stream position! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!next: requestedCount 	"Read requestedCount elements into new collection and return it,	 it could be that less elements were available"	^ self 		next: requestedCount 		into: (self collectionSpecies new: requestedCount)! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!next	^ peekedCharacter		ifNil: [ 			stream atEnd				ifFalse: [ self nextNonCommentChar ] ]		ifNotNil: [ | character |			character := peekedCharacter.			peekedCharacter := nil.			character ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!readInto: collection startingAt: offset count: requestedCount 	"Read count elements and place them in collection starting at offset.	Return the number of elements actually read."		^ peekedCharacter 		ifNil: [			0 to: requestedCount - 1 do: [ :count | | object |				(object := self nextNonCommentChar) ifNil: [ ^ count ].  				collection at: offset + count put: object ].			^ requestedCount ]		ifNotNil: [ 			collection at: offset put: peekedCharacter.			peekedCharacter := nil.			(self 				readInto: collection 				startingAt: offset + 1				count: requestedCount - 1) + 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!nextLine	"Read a CR, LF or CRLF terminated line, returning the contents of the line without the EOL. Return nil when the receiver is #atEnd."		self atEnd ifTrue: [ ^ nil ].	^ self collectionSpecies streamContents: [ :out | | eol char |		eol := false.		[ eol ] whileFalse: [ 			char := self next.			(char isNil or: [ char = Character lf ])				ifTrue: [ eol := true ]				ifFalse: [ 					char = Character cr 						ifTrue: [ eol := true. self peekFor: Character lf ]						ifFalse: [  out nextPut: char ] ] ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!peekFor: object	^ self peek = object		ifTrue: [ 			self next.			true ]		ifFalse: [ false ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!skip: count	count timesRepeat: [ self next ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!upToEnd	^ self collectionSpecies		streamContents: [ :collectionStream | 			[ self atEnd ] whileFalse: [ collectionStream nextPut: self next ] ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!wrappedStream	^ stream! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!next: requestedCount into: collection startingAt: offset	"Read requestedCount elements into collection starting at offset,	returning a copy if less elements are available"		| readCount |	readCount := self 		readInto: collection 		startingAt: offset 		count: requestedCount.	^ requestedCount = readCount		ifTrue: [ collection ]		ifFalse: [ collection copyFrom: 1 to: offset + readCount - 1 ]! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!next: requestedCount into: collection	"Read requestedCount elements into collection,	returning a copy if less elements are available"		^ self		next: requestedCount		into: collection		startingAt: 1! !!STONCStyleCommentsSkipStream methodsFor: 'accessing'!upTo: anObject 		^ self collectionSpecies 		streamContents: [ :out | | element |			[ self atEnd or: [ (element := self next) = anObject ] ] whileFalse: [ 				out nextPut: element ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONCStyleCommentsSkipStream class	instanceVariableNames: ''!!STONCStyleCommentsSkipStream class methodsFor: 'instance creation'!on: readStream	^ self new		on: readStream;		yourself! !FileReference subclass: #STONFileReference	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Core-Reader'!!STONFileReference commentStamp: '' prior: 0!I am STONFileReference, I am an implementation artifact to help reading objects with class tag equal to my #stonName.I am a FileReference.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONFileReference class	instanceVariableNames: ''!!STONFileReference class methodsFor: 'ston'!fromSton: stonReader	^ stonReader parseListSingleton asFileReference.! !!STONFileReference class methodsFor: 'ston'!stonName	^ #FILE! !Object subclass: #STONReader	instanceVariableNames: 'readStream objects classes unresolvedReferences stringStream acceptUnknownClasses newLine convertNewLines'	classVariableNames: ''	package: 'STON-Core-Reader'!!STONReader commentStamp: '' prior: 0!STONReader materializes objects using the Smalltalk Object Notation format.This parser is backwards compatible with standard JSON.Customization options are:- acceptUnknownClasses <Boolean> default is false	if true, unknown class names are allowed, the standard #mapClass (Dictionary) is instanciated and the class name is added under #classNameKey (#className)	if false, unknown class names result in a NotFound error- convertNewLines <Boolean> default is false	if true, any unescaped EOL sequence CR, LF or CRLF inside strings or symbols is read and converted as the chosen EOL sequence	if false, CR, LF and CRLF are read unmodified- newLine <String> default is String cr	sequence to use as EOL!!STONReader methodsFor: 'public'!next	| object |	self consumeWhitespace.	object := self parseValue.	unresolvedReferences > 0		ifTrue: [ self processSubObjectsOf: object ].	unresolvedReferences = 0		ifFalse: [ self error: 'Inconsistent reference resolution' ].	^ object! !!STONReader methodsFor: 'parsing-internal'!parseCharacter	| char |	^ (char := readStream next) = $\		ifTrue: [ self parseEscapedCharacter ]		ifFalse: [ char ]! !!STONReader methodsFor: 'parsing-internal'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [		number := 10 * number + readStream next digitValue.		power := power * 10.0 ].	^ number / power! !!STONReader methodsFor: 'parsing-internal'!parseCharacterHexDigit	| digit |	readStream atEnd ifFalse: [ 		digit := readStream next asInteger.		(digit between: "$0" 48 and: "$9" 57)			ifTrue: [ ^ digit - 48 ].		(digit between: "$A" 65 and: "$F" 70)			ifTrue: [ ^ digit - 55 ].		(digit between: "$a" 97 and: "$f" 102)			ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!STONReader methodsFor: 'parsing-internal'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			readStream next.			(readStream peek = $i)				ifTrue: [					self match: 'il' do: [ block value: nil ] ].			(readStream peek = $u)				ifTrue: [					self match: 'ull' do: [ block value: nil ] ] ]		! !!STONReader methodsFor: 'parsing-internal'!parseCharacterConvertingNewLinesOn: writeStream	| char |	(char := readStream next) = $\		ifTrue: [ writeStream nextPut: self parseEscapedCharacter ]		ifFalse: [ 			char = Character lf 				ifTrue: [ writeStream nextPutAll: newLine ]				ifFalse: [ 					char = Character cr 						ifTrue: [ 							readStream peekFor: Character lf.							writeStream nextPutAll: newLine ]						ifFalse: [ writeStream nextPut: char ] ] ]! !!STONReader methodsFor: 'parsing-internal'!parseClass	| className |	className := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isClassChar: readStream peek ] ] whileTrue: [ 			stream nextPut: readStream next ] ].	self consumeWhitespace.	^ self lookupClass: className asSymbol	! !!STONReader methodsFor: 'parsing-internal'!parseString	^ self parseStringInternal! !!STONReader methodsFor: 'parsing-internal'!parseSymbol	| string |	self expectChar: $#.	readStream peek = $'		ifTrue: [ ^ self parseStringInternal asSymbol ].	string := self stringStreamContents: [ :stream |		[ readStream atEnd not and: [ self isSimpleSymbolChar: readStream peek ] ] whileTrue: [			stream nextPut: readStream next ] ].	string isEmpty		ifFalse: [ 			self consumeWhitespace.			^ string asSymbol ].	self error: 'unexpected input'! !!STONReader methodsFor: 'parsing-internal'!parseNumberInteger	| number |	number := 0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] whileTrue: [ 		number := 10 * number + readStream next digitValue ].	^ number! !!STONReader methodsFor: 'parsing-internal'!parseEscapedCharacter	| char |	char := readStream next.	(#($' $" $/ $\) includes: char)		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char).	^ char! !!STONReader methodsFor: 'parsing-internal'!parseStringInternal	| result delimiter |	delimiter := readStream next.	(delimiter = $' or: [ delimiter = $" ])		ifFalse: [ self error: ''' or " expected' ].	result := self		stringStreamContents: [ :stream | 			convertNewLines				ifTrue: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ self parseCharacterConvertingNewLinesOn: stream ] ]				ifFalse: [ 					[ readStream atEnd or: [ readStream peek = delimiter ] ] 						whileFalse: [ stream nextPut: self parseCharacter ] ] ].	self expectChar: delimiter.	^ result! !!STONReader methodsFor: 'parsing-internal'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	^ 10 raisedTo: number! !!STONReader methodsFor: 'parsing-internal'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $/)		ifTrue: [ 			number := Fraction numerator: number denominator: self parseNumberInteger.			(readStream peekFor: $s)				ifTrue: [ number := ScaledDecimal newFromNumber: number scale: self parseNumberInteger ] ]		ifFalse: [ 			(readStream peekFor: $.)				ifTrue: [ number := number + self parseNumberFraction ].			((readStream peekFor: $e) or: [ readStream peekFor: $E ])				ifTrue: [ number := number * self parseNumberExponent ] ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!STONReader methodsFor: 'parsing-internal'!parseReference	| index |	self expectChar: $@.	index := self parseNumberInteger.	self consumeWhitespace.	unresolvedReferences := unresolvedReferences + 1.	^ STONReference index: index! !!STONReader methodsFor: 'error handling'!error: aString	| streamPosition |	"Remain compatible with streams that don't understand #position"	streamPosition := [ readStream position ]		on: MessageNotUnderstood do: [ nil ].	^ STONReaderError signal: aString streamPosition: streamPosition! !!STONReader methodsFor: 'initialize-release'!allowComplexMapKeys: boolean	"This is a no-op, this used to be an option, but it is now always enabled"! !!STONReader methodsFor: 'initialize-release'!acceptUnknownClasses: boolean	acceptUnknownClasses := boolean! !!STONReader methodsFor: 'initialize-release'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!STONReader methodsFor: 'initialize-release'!initialize	super initialize.	objects := IdentityDictionary new.	classes := IdentityDictionary new.	acceptUnknownClasses := convertNewLines := false.	newLine := String cr.	unresolvedReferences := 0! !!STONReader methodsFor: 'initialize-release'!on: aReadStream	readStream := aReadStream! !!STONReader methodsFor: 'initialize-release'!newLine: string	"Set the newline convention to be used when converting newlines, see #convertNewLines"		newLine := string ! !!STONReader methodsFor: 'initialize-release'!convertNewLines: boolean	"When true, any newline CR, LF or CRLF read unescaped inside strings or symbols 	will be converted to the newline convention chosen, see #newLine:	The default is false, not doing any convertions."		convertNewLines := boolean! !!STONReader methodsFor: 'initialize-release'!reset	unresolvedReferences := 0.	objects removeAll! !!STONReader methodsFor: 'initialize-release'!optimizeForLargeStructures	self class environment		at: #FLLargeIdentityDictionary		ifPresent: [ :identityDictionaryClass | objects := identityDictionaryClass new ]! !!STONReader methodsFor: 'testing'!atEnd	^ readStream atEnd! !!STONReader methodsFor: 'private'!resolveReferenceIndex: index	^ objects at: index! !!STONReader methodsFor: 'private'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!STONReader methodsFor: 'private'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!STONReader methodsFor: 'private'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!STONReader methodsFor: 'private'!isSimpleSymbolChar: char	^char isLetter or: ['0123456789-_./' includes: char]! !!STONReader methodsFor: 'private'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ readStream next ]! !!STONReader methodsFor: 'private'!processSubObjectsOf: object	| unresolvedReferencesCount |	unresolvedReferencesCount := unresolvedReferences.	object stonProcessSubObjects: [ :each | 		each isStonReference			ifTrue: [ self resolveReference: each ]			ifFalse: [ 				each stonContainSubObjects					ifTrue: [ self processSubObjectsOf: each ]					ifFalse: [ each ] ] ].	unresolvedReferencesCount > unresolvedReferences		ifTrue: [ object stonPostReferenceResolution ].	^ object! !!STONReader methodsFor: 'private'!stringStreamContents: block	stringStream ifNil: [ 		stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!STONReader methodsFor: 'private'!resolveReference: reference	unresolvedReferences := unresolvedReferences - 1.	^ self resolveReferenceIndex: reference index! !!STONReader methodsFor: 'private'!isClassChar: char	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_' includes: char! !!STONReader methodsFor: 'private'!storeReference: object	| index |	index := objects size + 1.	objects at: index put: object.	^ index! !!STONReader methodsFor: 'private'!setReference: reference to: object	objects at: reference index put: object! !!STONReader methodsFor: 'private'!isClassStartChar: char	^ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' includes: char! !!STONReader methodsFor: 'private'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!STONReader methodsFor: 'private'!lookupClass: name	"name is a symbol at this point"	Smalltalk globals 		at: name 		ifPresent: [ :class | ^ class ].	"note that classes is an identity dictionary"	^ classes 		at: name 		ifAbsentPut: [			Object allSubclasses 				detect: [ :class | class isMeta not and: [ class stonName = name ]  ]				ifNone: [ NotFound signalFor: name ] ]	! !!STONReader methodsFor: 'private'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!STONReader methodsFor: 'private'!newReference	| index reference |	index := objects size + 1.	reference := STONReference index: index.	objects at: index put: reference.	^ reference! !!STONReader methodsFor: 'private'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!STONReader methodsFor: 'parsing'!parseMapOrListRepresentation	"Parse either a map or list to be used as a representation, not considering it as a referenceable object"	readStream atEnd 		ifFalse: [ 			readStream peek = ${				ifTrue: [ | map |					map := STON mapClass new.					self parseMapDo: [ :key :value |						map at: key put: value ].					^ map ].			readStream peek = $[				ifTrue: [ 					^ STON listClass streamContents: [ :stream |						self parseListDo: [ :each | stream nextPut: each ] ] ] ].	self error: 'invalid input'! !!STONReader methodsFor: 'parsing'!parseMap	| map |	map := STON mapClass new.	self storeReference: map.	self parseMapDo: [ :key :value |		map at: key put: value ].	^ map! !!STONReader methodsFor: 'parsing'!parseList	| reference array |	reference := self newReference.	array := STON listClass streamContents: [ :stream |		self parseListDo: [ :each | stream nextPut: each ] ].	self setReference: reference to: array.	^ array! !!STONReader methodsFor: 'parsing'!parseObject	| targetClass reference object |	[		reference := self newReference.		targetClass := self parseClass.		object := targetClass fromSton: self .		self setReference: reference to: object ]		on: NotFound 		do: [ :notFound |			acceptUnknownClasses 				ifTrue: [ 					object := STON mapClass new.					self storeReference: object.					self parseMapDo: [ :key :value |						object at: key put: value ].					object at: STON classNameKey put: notFound object ]				ifFalse: [ self error: 'Cannot resolve class named ', notFound object printString ] ].	^ object! !!STONReader methodsFor: 'parsing'!parseSimpleValue	| char |	readStream atEnd ifFalse: [ 		(self isClassStartChar: (char := readStream peek)) 			ifTrue: [ ^ self parseObject ].		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		(char = $' or: [ char = $" ])			ifTrue: [ ^ self parseString ].		char = $#			ifTrue: [ ^ self parseSymbol ].		char = $@			ifTrue: [ ^ self parseReference ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input'! !!STONReader methodsFor: 'parsing'!parseListSingleton	| value |	value := nil.	self parseListDo: [ :each :index |		index = 1 ifTrue: [ value := each ] ].	^ value! !!STONReader methodsFor: 'parsing'!parseValue	| value |	value := self parseSimpleValue.	^ (self matchChar: $:)		ifTrue: [ STON associationClass key: value value: self parseValue ]		ifFalse: [ value ]! !!STONReader methodsFor: 'parsing'!parseMapDo: block	self expectChar: ${.	(self matchChar: $}) ifTrue: [ ^ self ]. "short cut for empty maps"	[ readStream atEnd ] whileFalse: [ | name value |		name := self parseSimpleValue.		self expectChar: $:.		value := self parseValue.		block value: name value: value.		"The above is a more efficient way to say 'self parseValue' and using the returned association"		(self matchChar: $}) ifTrue: [ ^ self ].		self expectChar: $, ].	self error: 'end of map expected'! !!STONReader methodsFor: 'parsing'!parseListDo: block	| index |	self expectChar: $[.	(self matchChar: $]) ifTrue: [ ^ self ]. "short cut for empty lists"	index := 1.	[ readStream atEnd ] whileFalse: [		block cull: self parseValue cull: index.		(self matchChar: $]) ifTrue: [ ^ self ].		index := index + 1.		self expectChar: $, ].	self error: 'end of list expected'! !!STONReader methodsFor: 'parsing'!parseNamedInstVarsFor: anObject	self parseMapDo: [ :instVarName :value |		anObject instVarNamed: instVarName asString put: value ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONReader class	instanceVariableNames: ''!!STONReader class methodsFor: 'instance creation'!on: readStream	^ self new		on: readStream;		yourself! !Error subclass: #STONReaderError	instanceVariableNames: 'streamPosition'	classVariableNames: ''	package: 'STON-Core-Reader'!!STONReaderError commentStamp: '' prior: 0!STONReaderError is the error/exception signalled by STONReader when illegal/incorrect input is seen. !!STONReaderError methodsFor: 'accessing'!streamPosition: aNumber	streamPosition := aNumber! !!STONReaderError methodsFor: 'accessing'!streamPosition	^ streamPosition! !!STONReaderError methodsFor: 'accessing'!messageText	^ streamPosition 		ifNil: [ 			super messageText ] 		ifNotNil: [ :pos | 			'At character <1P>: <2P>' expandMacrosWith: pos with: super messageText ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONReaderError class	instanceVariableNames: ''!!STONReaderError class methodsFor: 'instance creation'!signal: aString streamPosition: streamPosition 	^ self new		streamPosition: streamPosition;		signal: aString;		yourself! !Object subclass: #STONReference	instanceVariableNames: 'index'	classVariableNames: ''	package: 'STON-Core-Reader'!!STONReference commentStamp: '' prior: 0!STONReference holds a forward reference to another object during materialization.!!STONReference methodsFor: 'testing'!isStonReference	^ true! !!STONReference methodsFor: 'comparing'!= anObject	^ self class == anObject class and: [ self index = anObject index ]! !!STONReference methodsFor: 'comparing'!hash	^ index hash! !!STONReference methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: index; nextPut: $)! !!STONReference methodsFor: 'accessing'!index	^ index! !!STONReference methodsFor: 'accessing'!index: integer	index := integer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONReference class	instanceVariableNames: ''!!STONReference class methodsFor: 'instance creation'!index: integer	^ self new		index: integer;		yourself! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.349734 pm'!!Number methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.35384 pm'!!Number methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeFloat: self asFloat! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.3555 pm'!!Set methodsFor: '*ston-core'!stonPostReferenceResolution	"When references were resolved in me, the hash of my elements might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.355831 pm'!!Class methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter 		writeObject: self 		listSingleton: self name asSymbol! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.356176 pm'!!Color methodsFor: '*ston-core'!stonContainSubObjects	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.35652 pm'!!Color methodsFor: '*ston-core'!stonOn: stonWriter	| name |	(self isTranslucent or: [ (name := self name) = #unnamed ])		ifTrue: [ 			stonWriter writeObject: self streamMap: [ :map |				#(red green blue alpha) do: [ :each | 					map at: each put: ((self perform: each) roundTo: 0.001) ] ] ]		ifFalse: [ 			stonWriter writeObject: self listSingleton: name ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.356836 pm'!!Interval methodsFor: '*ston-core'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		stonReader parseNamedInstVarsFor: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.360896 pm'!!Interval methodsFor: '*ston-core'!stonOn: stonWriter	"Overwritten to get back the standard object behavior"	stonWriter writeObject: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.361214 pm'!!Point methodsFor: '*ston-core'!fromSton: stonReader	stonReader parseListDo: [ :each :index |		index = 1 ifTrue: [ x := each ].		index = 2 ifTrue: [ y := each ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.364156 pm'!!Point methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeObject: self streamShortList: [ :array |		array add: x; add: y ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.364499 pm'!!ClassDescription methodsFor: '*ston-core'!stonContainSubObjects	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.364911 pm'!!ByteArray methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.365265 pm'!!ByteArray methodsFor: '*ston-core'!stonOn: stonWriter	"Use a hex representation"		stonWriter writeObject: self listSingleton: self hex! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.36561 pm'!!DateAndTime methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.368225 pm'!!DateAndTime methodsFor: '*ston-core'!stonOn: stonWriter	"Use an ISO representation with all details YYYY-MM-DDTHH:MM:SS.N+TZ (with optional nanoseconds and timezone offset)"		stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream |			self printOn: stream withLeadingSpace: false ])! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.369116 pm'!!OrderedDictionary methodsFor: '*ston-core'!stonOn: stonWriter	"I store my instances as maps. When in JSON mode, 	encode me directly, without a class tag, keeping the order."		stonWriter jsonMode 		ifTrue: [ 			stonWriter encodeMap: self ] 		ifFalse: [ 			stonWriter 				writeObject: self 				do: [ stonWriter encodeMap: self ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.370976 pm'!!ZnMimeType methodsFor: '*ston-core'!stonContainSubObjects	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.372663 pm'!!ZnMimeType methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeObject: self listSingleton: self asString ! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.373001 pm'!!SmallDictionary methodsFor: '*ston-core'!stonOn: stonWriter	"I store my instances as maps"		stonWriter 		writeObject: self 		do: [ stonWriter encodeMap: self ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.373411 pm'!!Time methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.375911 pm'!!Time methodsFor: '*ston-core'!stonOn: stonWriter	"Use an ISO style HH:MM:SS.N representation (with optional nanoseconds)"	 	stonWriter writeObject: self listSingleton: 		(String streamContents: [ :stream |			self print24: true showSeconds: true on: stream ])! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.376222 pm'!!Dictionary methodsFor: '*ston-core'!stonPostReferenceResolution	"When references were resolved in me, the hash of my keys might have changed.	Check if I am still healthy and rehash me if not."		self isHealthy ifFalse: [ self rehash ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.376556 pm'!!Dictionary methodsFor: '*ston-core'!stonOn: stonWriter	"Instances of STON mapClass will be encoded directly, without a class tag.	Other (sub)classes will be encoded with a class tag and will use a map representation. "		self class == STON mapClass		ifTrue: [ 			stonWriter writeMap: self ]		ifFalse: [ 			stonWriter 				writeObject: self 				do: [ stonWriter encodeMap: self ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.376922 pm'!!ScaledDecimal methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeScaledDecimal: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.377287 pm'!!ZnUrl methodsFor: '*ston-core'!stonContainSubObjects	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.377563 pm'!!ZnUrl methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeObject: self listSingleton: self asString ! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.377842 pm'!!Symbol methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeSymbol: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.378161 pm'!!SequenceableCollection methodsFor: '*ston-core'!stonOn: stonWriter	"Instances of STON listClass will be encoded directly, without a class tag.	Other (sub)classes will be encoded with a class tag and will use a list representation. "	self class == STON listClass		ifTrue: [ stonWriter writeList: self ]		ifFalse: [ super stonOn: stonWriter ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.378621 pm'!!FileReference methodsFor: '*ston-core'!stonContainSubObjects	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.381683 pm'!!FileReference methodsFor: '*ston-core'!stonOn: stonWriter	self fileSystem isDiskFileSystem		ifTrue: [ | diskFilePath |			"in order to get $/ as delimiter and $. as working directory on all platforms"			diskFilePath := path isWorkingDirectory				ifTrue: [ '.' ]				ifFalse: [ path pathString ].			stonWriter 				writeObject: self 				named: STONFileReference stonName 				listSingleton: diskFilePath ]		ifFalse: [ 			super stonOn: stonWriter ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.382063 pm'!!Path methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter 		writeObject: self 		streamShortList: [ :listWriter | 			self do: [ :each | listWriter add: each ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.383665 pm'!!UndefinedObject methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.386103 pm'!!UndefinedObject methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeNull! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.386466 pm'!!Integer methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeInteger: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.388772 pm'!!Collection methodsFor: '*ston-core'!stonOn: stonWriter	"For collections we chose to write a list of elements as delivered by #do:	This is not the best or most correct solution for all subclasses though,	so some will revert to standard object behavior or chose another solution"		stonWriter writeObject: self do: [		stonWriter encodeList: self ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.389128 pm'!!Boolean methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.389514 pm'!!Boolean methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeBoolean: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.389823 pm'!!Date methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.391278 pm'!!Date methodsFor: '*ston-core'!stonOn: stonWriter	"Use an ISO style YYYY-MM-DD representation.	Since my current implementation is time zone offset sensitive, the offset has to be included."	| representation |	representation := self offset isZero		ifTrue: [ 			String new: 11 streamContents: [ :out | 				self printOn: out format: #(3 2 1 $- 1 1 2).				out nextPut: $Z ] ]		ifFalse: [ 			String new: 32 streamContents: [ :out | 				self printOn: out format: #(3 2 1 $- 1 1 2).				out nextPut: (self offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).				self offset hours abs printOn: out base: 10 length: 2 padded: true.				out nextPut: $:.				self offset minutes abs printOn: out base: 10 length: 2 padded: true.				self offset seconds = 0 					ifFalse:[ 						out nextPut: $:; print: self offset seconds abs truncated ] ] ].	stonWriter writeObject: self listSingleton: representation! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.391637 pm'!!Association methodsFor: '*ston-core'!stonOn: stonWriter	self class == STON associationClass		ifTrue: [ stonWriter writeAssociation: self ]		ifFalse: [ super stonOn: stonWriter ]	! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.392011 pm'!!Metaclass methodsFor: '*ston-core'!stonName	^ #Class! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.392376 pm'!!Metaclass methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter		writeObject: self 		listSingleton: self instanceSide name asSymbol! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.392697 pm'!!Character methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeObject: self listSingleton: self asString! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.396086 pm'!!Object methodsFor: '*ston-core'!stonContainSubObjects	"Return true if I contain subObjects that should be processed, false otherwise.	Overwrite when necessary. See also #stonProcessSubObjects:"		^ true! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.39643 pm'!!Object methodsFor: '*ston-core'!stonPostReferenceResolution	"Hook that is called when references were resolved processing this object or one of its sub objects. This will most probably influence hash values. Override to take appropriate action."! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.396762 pm'!!Object methodsFor: '*ston-core'!isStonReference	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.397073 pm'!!Object methodsFor: '*ston-core'!stonProcessSubObjects: block	"Execute block to (potentially) change each of my subObjects.	In general, all instance and indexable variables are processed.	Overwrite when necessary. Not used when #stonContainSubObjects returns false."		1 to: self class instSize do: [ :each |		self instVarAt: each put: (block value: (self instVarAt: each)) ].	(self class isVariable and: [ self class isBytes not ])		ifTrue: [			1 to: self basicSize do: [ :each |				self basicAt: each put: (block value: (self basicAt: each)) ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.397419 pm'!!Object methodsFor: '*ston-core'!fromSton: stonReader	"Decode non-variable classes from a map of their instance variables and values.	Override to customize and add a matching #toSton: (see implementors)."		self class isVariable 		ifTrue: [			stonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ]		ifFalse: [			stonReader parseNamedInstVarsFor: self ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.397782 pm'!!Object methodsFor: '*ston-core'!stonShouldWriteNilInstVars	"Return true if my instance variables that are nil should be written out, 	false otherwise. Overwrite when necessary. By default, return false."		^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.398104 pm'!!Object methodsFor: '*ston-core'!stonOn: stonWriter	"Encode non-variable classes with a map of their instance variable and values.	Override to customize and add a matching #fromSton: (see implementors)."	self class isVariable 		ifTrue: [			stonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ]		ifFalse: [			stonWriter writeObject: self ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.398428 pm'!!Fraction methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeFraction: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.401511 pm'!!Bag methodsFor: '*STON-Core'!stonOn: stonWriter	"Use a map with element-occurences pairs as representation"	stonWriter 		writeObject: self 		do: [ stonWriter encodeMap: contents ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.401886 pm'!!String methodsFor: '*ston-core'!stonContainSubObjects 	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.405613 pm'!!String methodsFor: '*ston-core'!stonOn: stonWriter	stonWriter writeString: self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.408258 pm'!!Date class methodsFor: '*ston-core'!fromSton: stonReader	"Read a ISO YYYY-MM-DD format.	Since my current implementation is time zone offset sensitive, the offset has to be taken into account.	A missing offset results in the local timezone offset to be used"		| readStream date |	readStream := stonReader parseListSingleton readStream.	date := self readFrom: readStream.	readStream atEnd		ifFalse: [ | offset |			offset := DateAndTime readTimezoneOffsetFrom: readStream.			offset = date offset 				ifFalse: [ date start: (date start translateTo: offset) ] ].	^ date! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.408641 pm'!!ZnMimeType class methodsFor: '*ston-core'!stonName	^ #MimeType! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.409008 pm'!!ZnMimeType class methodsFor: '*ston-core'!fromSton: stonReader	^ self fromString: stonReader parseListSingleton! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.409403 pm'!!Dictionary class methodsFor: '*ston-core'!fromSton: stonReader	"Instances of STON mapClass will be read directly and won't arrive here.	Other (sub)classes will use this method."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.409777 pm'!!Color class methodsFor: '*ston-core'!fromSton: stonReader	| representation |	representation := stonReader parseMapOrListRepresentation.	^ representation isArray		ifTrue: [ 			self named: representation first ]		ifFalse: [ 			(representation includesKey: #rgb)				ifTrue: [ 					self basicNew setRGB: (representation at: #rgb); setAlpha: 1.0 "backwards compatibility" ]				ifFalse: [ 					self 						r: (representation at: #red) 						g: (representation at: #green) 						b: (representation at: #blue) 						alpha: (representation at: #alpha) ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.410135 pm'!!Interval class methodsFor: '*ston-core'!fromSton: stonReader	"Overwritten to get back the standard object behavior"		^ self new		fromSton: stonReader;		yourself! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.410513 pm'!!OrderedDictionary class methodsFor: '*ston-core'!fromSton: stonReader	"My instances are stored as maps."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.410926 pm'!!Path class methodsFor: '*ston-core'!fromSton: stonReader	| elements |	elements := Array streamContents: [ :out |		stonReader parseListDo: [ :each | out nextPut: each ] ].	^ self withAll: elements! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.411273 pm'!!Collection class methodsFor: '*ston-core'!fromSton: stonReader	"For collections we chose to instanciate based a list of elements using #add:	This is not the best or most correct solution for all subclasses though,	so some will revert to standard object behavior or chose another solution."		| collection |	collection := self new.	stonReader parseListDo: [ :each |		collection add: each ].	^ collection! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.411643 pm'!!Character class methodsFor: '*ston-core'!fromSton: stonReader	^ stonReader parseListSingleton first! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.412002 pm'!!Bag class methodsFor: '*STON-Core'!fromSton: stonReader	"Read a map representation containing element/occurences pairs"		| bag |	bag := self new.	stonReader parseMapDo: [ :key :value |		bag add: key withOccurrences: value ].	^ bag! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.412349 pm'!!Object class methodsFor: '*ston-core'!stonName	"Override to encode my instances using a different class name.	Use symbols as class name/tag."		^ self name! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.412682 pm'!!Object class methodsFor: '*ston-core'!stonAllInstVarNames	"Override to encode my instances using a custom set of instance variables or to define their order."		^ self allInstVarNames ! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.413008 pm'!!Object class methodsFor: '*ston-core'!fromSton: stonReader	"Create a new instance and delegate decoding to instance side.	Override only when new instance should be created directly (see implementors). "		^ self new		fromSton: stonReader;		yourself! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.413344 pm'!!SequenceableCollection class methodsFor: '*ston-core'!fromSton: stonReader	"Overwritten to use #streamContents: and #nextPut:"		^ self streamContents: [ :stream |		stonReader parseListDo: [ :each |			stream nextPut: each ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.413776 pm'!!Time class methodsFor: '*ston-core'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.414122 pm'!!Class class methodsFor: '*ston-core'!fromSton: stonReader	| theClassName theClass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	^ theClass! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.414475 pm'!!ZnUrl class methodsFor: '*ston-core'!stonName	^ #URL! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.414743 pm'!!ZnUrl class methodsFor: '*ston-core'!fromSton: stonReader	^ self fromString: stonReader parseListSingleton ! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.415007 pm'!!DateAndTime class methodsFor: '*ston-core'!fromSton: stonReader	^ self readFrom: stonReader parseListSingleton readStream! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.415428 pm'!!ByteArray class methodsFor: '*ston-core'!fromSton: stonReader	"Use a hex representation"		^ self readHexFrom: stonReader parseListSingleton! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.415831 pm'!!SmallDictionary class methodsFor: '*ston-core'!fromSton: stonReader	"My instances are stored as maps."		| dictionary |	dictionary := self new.	stonReader parseMapDo: [ :key :value |		dictionary at: key put: value ].	^ dictionary! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 2 May 2021 at 12:15:50.416218 pm'!!Metaclass class methodsFor: '*ston-core'!fromSton: stonReader	| theClassName theClass theMetaclass |	theClassName := stonReader parseListSingleton.	theClass := self environment at: theClassName.	theMetaclass := theClass class.	^ theMetaclass! !