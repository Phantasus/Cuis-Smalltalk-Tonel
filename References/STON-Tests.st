TestCase subclass: #STONCStyleCommentsSkipStreamTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Reader'!!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testNonComment	self assert: (STONCStyleCommentsSkipStream on: 'foo' readStream) upToEnd equals: 'foo'.	self assert: (STONCStyleCommentsSkipStream on: 'foo' readStream) nextLine equals: 'foo'.	self deny: (STONCStyleCommentsSkipStream on: 'foo' readStream) atEnd.	self assert: (STONCStyleCommentsSkipStream on: '' readStream) atEnd.! !!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testCommentInString	self 		assert: (STONCStyleCommentsSkipStream on: '''/*comment*/''' readStream) upToEnd 		equals: '''/*comment*/'''.	self 		assert: (STONCStyleCommentsSkipStream on: '{''foo'':''/*comment*/bar''}' readStream) upToEnd 		equals: '{''foo'':''/*comment*/bar''}'.	self 		assert: (STONCStyleCommentsSkipStream on: '{''foo'':''//comment\''bar''}' readStream) upToEnd 		equals: '{''foo'':''//comment\''bar''}'.	self 		assert: (STONCStyleCommentsSkipStream on: '{"foo":"/*comment*/bar"}' readStream) upToEnd 		equals: '{"foo":"/*comment*/bar"}'.	self 		assert: (STONCStyleCommentsSkipStream on: '{"foo":"//comment\"bar"}' readStream) upToEnd 		equals: '{"foo":"//comment\"bar"}'! !!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testBlockReading	| input buffer |	input := STONCStyleCommentsSkipStream on: 'abc/*comment*/def' readStream.	buffer := String new: 6.	self assert: (input readInto: buffer startingAt: 1 count: 4) equals: 4.	self assert: (buffer copyFrom: 1 to: 4) equals: 'abcd'.	self assert: (input readInto: buffer startingAt: 5 count: 4) equals: 2.	self assert: buffer equals: 'abcdef'.	input := STONCStyleCommentsSkipStream on: 'abc//comment\def' withCRs readStream.	buffer := String new: 6.	self assert: (input readInto: buffer startingAt: 1 count: 6) equals: 6.	self assert: buffer equals: 'abcdef'.	self assert: input atEnd! !!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testSTON	"Comments are processed first and totally removed.	They are not even whitespace (not that whitespace is relevant in STON)."		self 		assert: (STON fromStream: (STONCStyleCommentsSkipStream on: '123/*comment*/456' readStream)) 		equals: 123456.	self 		assert: (STON fromStream: (STONCStyleCommentsSkipStream on: '/*comment*/''abcd''' readStream)) 		equals: 'abcd'.	self 		assert: (STON fromStream: (STONCStyleCommentsSkipStream on: '123//456' readStream)) 		equals: 123.	self 		should: [ STON fromStream: (STONCStyleCommentsSkipStream on: '//456' readStream) ] 		raise: STONReaderError! !!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testSingleLineComment	self assert: (STONCStyleCommentsSkipStream on: 'foo/*comment*/bar' readStream) upToEnd equals: 'foobar'.	self assert: (STONCStyleCommentsSkipStream on: 'foo/*comment*/bar' readStream) nextLine equals: 'foobar'.	self deny: (STONCStyleCommentsSkipStream on: 'foo/*comment*/bar' readStream) atEnd.	self assert: (STONCStyleCommentsSkipStream on: '/*comment*/' readStream) atEnd.! !!STONCStyleCommentsSkipStreamTest methodsFor: 'testing'!testMultiLineComment	self 		assert: (STONCStyleCommentsSkipStream on: 'foo\//comment\bar' withCRs readStream) upToEnd 		equals: 'foo\bar' withCRs.	self 		assert: (STONCStyleCommentsSkipStream on: 'foo\//comment\bar' withCRs readStream) nextLine		equals: 'foo'.	self 		assert: ((STONCStyleCommentsSkipStream on: 'foo\//comment\bar' withCRs readStream) nextLine; nextLine) 		equals: 'bar'.	self assert: (STONCStyleCommentsSkipStream on: '//comment' readStream) atEnd.! !TestCase subclass: #STONReaderTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Reader'!!STONReaderTest commentStamp: '' prior: 0!STONReaderTests test materialization.!!STONReaderTest methodsFor: 'tests'!testClass	self assert: (self materialize: 'Class[#Point]') equals: Point! !!STONReaderTest methodsFor: 'tests'!testDictionaryWithComplexKeys	| collection reader |	collection := STON mapClass new		at: true put: 1;		at: #(foo) put: 2;		yourself.	"allowing complex map keys used to be optional, now it is always the default"	reader := STONReader on: '{true:1,[#foo]:2}' readStream.	self assert: reader next equals: collection! !!STONReaderTest methodsFor: 'tests'!testDateAndTime	| dateAndTime |	dateAndTime := DateAndTime		year: 2012		month: 1		day: 1		hour: 6		minute: 30		second: 15		offset: 1 hour.	self assert: (self materialize: 'DateAndTime[''2012-01-01T06:30:15+01:00'']') equals: dateAndTime! !!STONReaderTest methodsFor: 'tests'!testMap	self		assert: (self materialize: '{#foo:1}')		equals:			(STON mapClass new				at: #foo put: 1;				yourself).	self assert: (self materialize: '{}') equals: STON mapClass new! !!STONReaderTest methodsFor: 'tests'!testJsonString	"Allow double quotes for backwards JSON compatibility"	| string |	self assert: (self materialize: '"foo"') equals: 'foo'.	self assert: (self materialize: '"FOO"') equals: 'FOO'.	self assert: (self materialize: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'élève en Français'.	string := String withAll: {$" . $' . $\ . Character tab . Character cr . Character lf . Character newPage . Character backspace}.	self assert: (self materialize: '"\"\''\\\t\r\n\f\b"') equals: string! !!STONReaderTest methodsFor: 'tests'!testDictionary	| collection |	collection := STON mapClass new		at: 1 put: 1;		at: 2 put: 2;		yourself.	self assert: (self materialize: '{1:1,2:2}') equals: collection.	self assert: (self materialize: '{}') equals: STON mapClass new! !!STONReaderTest methodsFor: 'tests'!testAssociation	self assert: (self materialize: '''foo'':1') equals: 'foo' -> 1.	self assert: (self materialize: '#bar:2') equals: #bar -> 2.	self assert: (self materialize: '''foo bar'':#ok') equals: 'foo bar' -> #ok.	self assert: (self materialize: '123:456') equals: 123 -> 456.	self assert: (self materialize: '''foo'' : 1') equals: 'foo' -> 1.	self assert: (self materialize: '#bar : 2') equals: #bar -> 2.	self assert: (self materialize: '''foo bar'' : #ok') equals: 'foo bar' -> #ok.	self assert: (self materialize: '123 : -456') equals: 123 -> -456.	self assert: (self materialize: '#foo : 1 : 2') equals: #foo -> (1 -> 2)! !!STONReaderTest methodsFor: 'tests'!testByteArray	self assert: (self materialize: 'ByteArray[''010203'']') equals: #(1 2 3) asByteArray! !!STONReaderTest methodsFor: 'tests'!testError	#( 'foo' '{foo:}' '{foo,}' '[1,]' '+1' ']' '#' '' '  ' '	' 'nul' 'tru' 'fals' ) do: [ :each |		self 			should: [ self materialize: each ] 			raise: STONReaderError ]! !!STONReaderTest methodsFor: 'tests'!testReferenceCycle	| array |	array := self materialize: '[1,@1]'.	self assert: array class equals: STON listClass.	self assert: array size equals: 2.	self assert: array first equals: 1.	self assert: array second identicalTo: array! !!STONReaderTest methodsFor: 'tests'!testMimeType	self 		assert: (self materialize: 'MimeType[''application/json'']') 		equals: ZnMimeType applicationJson.	self 		assert: (self materialize: 'MimeType[''text/plain;charset=utf-8'']') 		equals: ZnMimeType textPlain.! !!STONReaderTest methodsFor: 'tests'!testMetaclass	self assert: (self materialize: 'Metaclass[#Point]') equals: Point class! !!STONReaderTest methodsFor: 'tests'!testNull	self assert: (self materialize: 'null') isNil! !!STONReaderTest methodsFor: 'tests'!testURL	self 		assert: (self materialize: 'URL[''https://pharo.org/files/pharo.png'']') 		equals: 'https://pharo.org/files/pharo.png' asUrl.	self 		assert: (self materialize: 'URL[''mailto:sven@stfx.eu'']') 		equals: 'mailto:sven@stfx.eu' asUrl.	self 		assert: (self materialize: 'URL[''file:///var/log/system.log'']') 		equals: 'file:///var/log/system.log' asUrl.	self 		assert: (self materialize: 'URL[''scheme://user:password@host:123/var/log/system.log?foo=1&bar#frag'']') 		equals: 'scheme://user:password@host:123/var/log/system.log?foo=1&bar#frag' asUrl.! !!STONReaderTest methodsFor: 'tests'!testBag	self 		assert: (self materialize: 'Bag{#a:2,#b:3}') 		equals: (Bag withAll: #(a a b b b)).	self 		assert: (self materialize: 'Bag{}') 		equals: Bag new.! !!STONReaderTest methodsFor: 'tests'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	object := (STON fromString: '''\uD834\uDD1E''').	self assert: object equals: string! !!STONReaderTest methodsFor: 'tests'!testDate	| date |	date := (Date year: 2012 month: 1 day: 1) translateToUTC.	self assert: (self materialize: 'Date[''2012-01-01Z'']') equals: date.	self assert: (self materialize: 'Date[''2012-01-01+00:00'']') equals: date.	date := (Date year: 2012 month: 1 day: 1) translateTo: 1 hour.	self assert: (self materialize: 'Date[''2012-01-01+01:00'']') equals: date.	"a missing timezone offset results in the local timezone offset being used,	this is never written by STON, but matches the first implementation for backwards compatibility"	date := Date year: 2012 month: 1 day: 1.	self assert: (self materialize: 'Date[''2012-01-01'']') equals: date.! !!STONReaderTest methodsFor: 'tests'!testUnknownClasses	| input object |	input := 'FooBar { #foo : 1, #bar : true }'.	self should: [ self materialize: input ] raise: STONReaderError.	object := STON reader 		acceptUnknownClasses: true; 		on: input readStream; 		next.	self assert: object class equals: STON mapClass.	self assert: (object at: #foo) equals: 1.	self assert: (object at: #bar).	self assert: (object at: STON classNameKey) equals: #FooBar! !!STONReaderTest methodsFor: 'tests'!testClassWithUnderscore	| cls data reader |	cls := Object newAnonymousSubclass.	cls setName: #A_B_C123AnonClass.	data := STON toString: cls new.	reader := STONReader on: data readStream.	(reader instVarNamed: #classes) 		at: cls name 		put: cls.	self assert: reader next class equals: cls! !!STONReaderTest methodsFor: 'tests'!testFraction	self assert: (self materialize: '1/3') equals: 1/3.	self assert: (self materialize: '-1/3') equals: -1/3.	self assert: (self materialize: '100/11') equals: 100/11.! !!STONReaderTest methodsFor: 'tests'!testSetWithIndirectReferenceElements	| elementsCollection set ston object |	elementsCollection := OrderedCollection streamContents: [ :out |		10 timesRepeat: [ out nextPut: UUID new ] ].	set := Set withAll: (elementsCollection collect: [ :each | Array with: each ]).	object := Array with: elementsCollection with: set.	ston := STON toStringPretty: object.	object := STON fromString: ston readStream.	object first do: [ :each |		self assert: (object second includes: (Array with: each)) ].	self assert: object second isHealthy ! !!STONReaderTest methodsFor: 'tests'!testFloat	self assert: ((self materialize: '1.5') closeTo: 1.5).	self assert: ((self materialize: '-1.5') closeTo: -1.5).	self assert: (self materialize: '0.0') isZero.	self assert: (Float pi closeTo: (self materialize: '3.14149')).	self assert: (1/3 closeTo: (self materialize: '0.333333')).	self assert: ((self materialize: '1.0e100') closeTo: (10 raisedTo: 100)).	self assert: ((self materialize: '1.0e-100') closeTo: (10 raisedTo: -100)).	self assert: ((self materialize: '-1.0e-100') closeTo: (10 raisedTo: -100) negated)! !!STONReaderTest methodsFor: 'tests'!testList	self assert: STON listClass equals: Array.	self assert: (self materialize: '[1,2,3]') equals: (STON listClass with: 1 with: 2 with: 3).	self assert: (self materialize: '[]') equals: STON listClass new! !!STONReaderTest methodsFor: 'tests'!testReferenceSharing	| one array |	one := {#one}.	array := self materialize: '[[#one],@2,@2]'.	self assert: array equals: (STON listClass with: one with: one with: one).	self assert: array first identicalTo: array second.	self assert: array first identicalTo: array third! !!STONReaderTest methodsFor: 'tests'!testStreaming	| reader |	reader := STON reader 		on: '1 2 3 4 5 6 7 8 9 10' readStream.	self 		assert: (Array streamContents: [ :stream |			[ reader atEnd] whileFalse: [ 				stream nextPut: reader next ] ]) sum		equals: #(1 2 3 4 5 6 7 8 9 10) sum! !!STONReaderTest methodsFor: 'tests'!testTime	| time |	time := Time hour: 6 minute: 30 second: 15.	self assert: (self materialize: 'Time[''06:30:15'']') equals: time.	time := Time hour: 6 minute: 30 second: 15 nanoSecond: 123.	self assert: (self materialize: 'Time[''06:30:15.000000123'']') equals: time.! !!STONReaderTest methodsFor: 'tests'!testNewSymbol	| n notASymbol shouldBeSymbol |		"Find a name that has not yet been interned"	n := 0.	[ Symbol hasInterned: (notASymbol := 'notASymbol', n printString) ifTrue: [ :symbol | symbol ] ] 		whileTrue: [ n := n + 1 ].	"Parsing the new, not yet interned name should create a new Symbol"	shouldBeSymbol := self materialize: '#', notASymbol.	self assert: (shouldBeSymbol isSymbol and: [ notASymbol = shouldBeSymbol asString ])! !!STONReaderTest methodsFor: 'tests'!testWhitespace	| whitespace |	whitespace := {Character space . Character tab . Character cr . Character lf}.	self assert: (self materialize: whitespace , '123') equals: 123! !!STONReaderTest methodsFor: 'tests'!testBoolean	self assert: (self materialize: 'true') equals: true.	self assert: (self materialize: 'false') equals: false! !!STONReaderTest methodsFor: 'tests'!testMultiple	| reader |	reader := STON reader 		on: '123 -123 nil #foo true [ 0 ] false { #one : 1 }' readStream.	self deny: reader atEnd.	self assert: reader next equals: 123. 	self assert: reader next equals: -123. 	self assert: reader next equals: nil. 	self assert: reader next equals: #foo. 	self assert: reader next equals: true. 	self assert: reader next equals: { 0 }. 	self assert: reader next equals: false. 	self assert: reader next equals: (Dictionary with: #one -> 1). 	self assert: reader atEnd.! !!STONReaderTest methodsFor: 'tests'!testString	| string |	self assert: (self materialize: '''foo''') equals: 'foo'.	self assert: (self materialize: '''FOO''') equals: 'FOO'.	self assert: (self materialize: '''\u00E9l\u00E8ve en Fran\u00E7ais''') equals: 'élève en Français'.	string := String withAll: {$" . $' . $\ . $/ . Character tab . Character cr . Character lf . Character newPage . Character backspace}.	self assert: (self materialize: '''\"\''\\\/\t\r\n\f\b''') equals: string! !!STONReaderTest methodsFor: 'tests'!testNil	self assert: (self materialize: 'nil') isNil! !!STONReaderTest methodsFor: 'tests'!testInteger	self assert: (self materialize: '1') equals: 1.	self assert: (self materialize: '-1') equals: -1.	self assert: (self materialize: '0') equals: 0.	self assert: (self materialize: '1234567890') equals: 1234567890.	self assert: (self materialize: '-1234567890') equals: -1234567890! !!STONReaderTest methodsFor: 'tests'!testDictionaryWithIndirectReferenceKeys	| keysCollection dictionary ston object |	keysCollection := OrderedCollection streamContents: [ :out |		10 timesRepeat: [ out nextPut: UUID new ] ].	dictionary := Dictionary new.	keysCollection doWithIndex: [ :each :index | 		dictionary at: (Array with: each) put: index ].	object := Array with: keysCollection with: dictionary.	ston := STON toStringPretty: object.	object := (STON reader on: ston readStream) next.	object first doWithIndex: [ :each :index |		self assert: (object second at: (Array with: each)) equals: index ].	self assert: object second isHealthy ! !!STONReaderTest methodsFor: 'tests'!testDiskFile	self assert: (self materialize: 'FILE[''foo.txt'']') equals: 'foo.txt' asFileReference.	self assert: (self materialize: 'FILE[''/tmp/foo.txt'']') equals: '/tmp/foo.txt' asFileReference.	self assert: (self materialize: 'FILE[''tmp/foo.txt'']') equals: 'tmp/foo.txt' asFileReference.	self assert: (self materialize: 'FILE[''/tmp'']') equals: '/tmp' asFileReference.! !!STONReaderTest methodsFor: 'tests'!testIllegalCharacterEscapes	self should: [ STON fromString: '''\a''' ] raise: STONReaderError.	self should: [ STON fromString: '''\u''' ] raise: STONReaderError.	self should: [ STON fromString: '''\u00''' ] raise: STONReaderError.	self should: [ STON fromString: '''\u000''' ] raise: STONReaderError.	self should: [ STON fromString: '''\*''' ] raise: STONReaderError! !!STONReaderTest methodsFor: 'tests'!testSetWithReferenceElements	| elementsCollection set ston object |	elementsCollection := OrderedCollection streamContents: [ :out |		10 timesRepeat: [ out nextPut: UUID new ] ].	set := Set withAll: elementsCollection.	object := Array with: elementsCollection with: set.	ston := STON toStringPretty: object.	object := STON fromString: ston readStream.	object first do: [ :each |		self assert: (object second includes: each) ].	self assert: object second isHealthy ! !!STONReaderTest methodsFor: 'tests'!testIdentityDictionary	| collection |	collection := IdentityDictionary new		at: 1 put: 1;		at: 2 put: 2;		yourself.	self assert: (self materialize: 'IdentityDictionary{1:1,2:2}') equals: collection.	self assert: (self materialize: 'IdentityDictionary{}') equals: IdentityDictionary new! !!STONReaderTest methodsFor: 'tests'!testUser	| user |	(user := STONTestUser new)		username: 'john@foo.com';		password: 'secret1'.	self assert: (self materialize: 'STONTestUser{#username:''john@foo.com'',#password:''secret1'',#enabled:true}') equals: user! !!STONReaderTest methodsFor: 'tests'!testDeepStructure	| holder deepest structure writer ston reader result |	"Create a deep nested structure so that the deepest element is a reference back to a top level holder."	holder := Array with: 42.	deepest := Array with: holder.	structure := deepest.	1 * 1024 timesRepeat: [ structure := Array with: structure ].	structure := Array with: holder with: structure.	writer := STON writer optimizeForLargeStructures.	ston := String streamContents: [ :out | (writer on: out) nextPut: structure ].	"After reading, the second pass will have to go down the structure to resolve the reference."	reader := STON reader optimizeForLargeStructures.	result := (reader on: ston readStream) next.	self assert: result equals: structure! !!STONReaderTest methodsFor: 'tests'!testSymbol	self assert: (self materialize: '#''foo''') equals: #foo.	self assert: (self materialize: '#foo') equals: #foo! !!STONReaderTest methodsFor: 'tests'!testConvertingNewLines	| input result output |	input := '''line ending with CR', String cr, 		'line ending with LF', String lf, 		'line ending with CRLF', String crlf, ''''.	output := 'line ending with CR', String crlf, 		'line ending with LF', String crlf, 		'line ending with CRLF', String crlf.	result := (STON reader on: input readStream) newLine: String crlf; convertNewLines: true; next.	self assert: result equals: output.	output := 'line ending with CR', String cr, 		'line ending with LF', String cr, 		'line ending with CRLF', String cr.	result := (STON reader on: input readStream) newLine: String cr; convertNewLines: true; next.	self assert: result equals: output! !!STONReaderTest methodsFor: 'tests'!testObject	self assert: (self materialize: 'Point[1,2]') equals: 1 @ 2.	self assert: (self materialize: 'Point[1.5,-0.5]') equals: 1.5 @ -0.5! !!STONReaderTest methodsFor: 'tests'!testPoint	self assert: (self materialize: 'Point[1,2]') equals: 1 @ 2! !!STONReaderTest methodsFor: 'tests'!testDictionaryWithReferenceKeys	| keysCollection dictionary ston object |	keysCollection := OrderedCollection streamContents: [ :out |		10 timesRepeat: [ out nextPut: UUID new ] ].	dictionary := Dictionary new.	keysCollection doWithIndex: [ :each :index | 		dictionary at: each put: index ].	object := Array with: keysCollection with: dictionary.	ston := STON toStringPretty: object.	object := (STON reader on: ston readStream) next.	object first doWithIndex: [ :each :index |		self assert: (object second at: each) equals: index ].	self assert: object second isHealthy ! !!STONReaderTest methodsFor: 'tests'!testUser2	| user |	(user := STONTestUser2 new)		username: 'john@foo.com';		password: 'secret1'.	self assert: (self materialize: 'STONTestUser2{#username:''john@foo.com'',#password:''secret1'',#enabled:true}') equals: user! !!STONReaderTest methodsFor: 'tests'!testCharacter	self assert: (self materialize: 'Character[''A'']') identicalTo: $A! !!STONReaderTest methodsFor: 'tests'!testScaledDecimal	self assert: (self materialize: '1/3s2') equals: 1/3s2.	self assert: (self materialize: '-1/3s2') equals: -1/3s2.	self assert: (self materialize: '1/3s10') equals: 1/3s10.	self assert: (self materialize: '-1/3s10') equals: -1/3s10.! !!STONReaderTest methodsFor: 'tests'!testWideSymbol	self assert: (self materialize: '#''яблоко''') equals: #яблоко.	self assert: (self materialize: '#яблоко') equals: #яблоко! !!STONReaderTest methodsFor: 'tests'!testOrderedCollection	| collection |	collection := OrderedCollection with: 1 with: 2 with: 3.	self assert: (self materialize: 'OrderedCollection[1,2,3]') equals: collection.	self assert: (self materialize: 'OrderedCollection[]') equals: OrderedCollection new! !!STONReaderTest methodsFor: 'tests'!testColor	self 		assert: (self materialize: 'Color[#red]')		equals: Color red.	self 		assert: (self materialize: 'Color{#red:1.0,#green:0.0,#blue:0.0,#alpha:0.4}')		equals: (Color red copy setAlpha: 0.4).	self 		assert: (self materialize: 'Color{#red:1.0,#green:0.061,#blue:0.061,#alpha:1.0}')		equals: Color red lighter lighter.! !!STONReaderTest methodsFor: 'private'!materialize: string	^ STON reader 		on: string readStream;		next! !TestCase subclass: #STONWriteReadTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Write-Read'!!STONWriteReadTest commentStamp: '' prior: 0!STONWriteReadTests test serialization followed by materialization, these tests first write then read STON.!!STONWriteReadTest methodsFor: 'tests'!testDatesAndTimes	| datesAndTimes |	datesAndTimes := STON listClass withAll: { 		Time now. 		Date today. 		DateAndTime now }.	self serializeAndMaterialize: datesAndTimes! !!STONWriteReadTest methodsFor: 'tests'!testFloats	| floats serialization materialization |	floats := STON listClass withAll: ((-10 to: 10) collect: [ :each | each * Float pi ]).	serialization := self serialize: floats.	materialization := self materialize: serialization.	self assert: floats size equals: materialization size.	1 to: floats size do: [ :index | 		| float |		float := floats at: index.		"Use #closeTo: instead of #= to increase portability"		self assert: (float closeTo: (materialization at: index)) ]! !!STONWriteReadTest methodsFor: 'tests'!testKnownObjects	| knownObject ston object |	knownObject := STONTestKnownObject new.	"make sure the system of remembering instances works"	self assert: (STONTestKnownObject fromId: knownObject id asString) equals: knownObject.	self assert: (STONTestKnownObject fromId: knownObject id asString) identicalTo: knownObject.	"only the id string is serialized"	ston := self serialize: knownObject.	"upon serialization, objects with known id strings come from the remembered instances"	object := self materialize: ston.	self assert: object equals: knownObject.	self assert: object identicalTo: knownObject.	"not just the id is equal, but the rest of the object too"	self assert: object description equals: knownObject description.	STONTestKnownObject resetKnownObjects! !!STONWriteReadTest methodsFor: 'tests'!testScaledDecimals	| fractions |	fractions := STON listClass withAll: (-2/3s2 to: 2/3s2 by: 1/3s2).	self serializeAndMaterialize: fractions! !!STONWriteReadTest methodsFor: 'tests'!testStrings	| strings |	strings := Collection allSubclasses 		collect: [ :each | each name asString ].	self serializeAndMaterialize: strings.	strings := { 		'foo'. 'Foo BAR'. ''. '	\\'''. 		'élève en Français'. 		String with: (Character codePoint: 12354) "HIRAGANA LETTER A" }.	self serializeAndMaterialize: strings.! !!STONWriteReadTest methodsFor: 'tests'!testUser	| user users |	user := STONTestUser dummy.	self serializeAndMaterialize: user.	users := STON listClass streamContents: [ :stream |		10 timesRepeat: [ stream nextPut: STONTestUser dummy ] ].	self serializeAndMaterialize: users.	users := STON mapClass new.	10 timesRepeat: [ | newUser |		newUser := STONTestUser dummy.		users at: newUser username put: newUser ].	self serializeAndMaterialize: users.! !!STONWriteReadTest methodsFor: 'tests'!testUser2	| user users |	user := STONTestUser2 dummy.	self serializeAndMaterialize: user.	users := STON listClass streamContents: [ :stream |		10 timesRepeat: [ stream nextPut: STONTestUser2 dummy ] ].	self serializeAndMaterialize: users.	users := STON mapClass new.	10 timesRepeat: [ | newUser |		newUser := STONTestUser2 dummy.		users at: newUser username put: newUser ].	self serializeAndMaterialize: users.! !!STONWriteReadTest methodsFor: 'tests'!testDiskFiles	| diskFiles |	diskFiles := STON listClass withAll: { 		FileLocator image asFileReference.		FileLocator workingDirectory asAbsolute.		'foo/bar/readme.txt' asFileReference.		'./readme.txt' asFileReference.		(FileLocator home / 'foo.txt') asFileReference }.	self serializeAndMaterialize: diskFiles! !!STONWriteReadTest methodsFor: 'tests'!testColors	| colors |	colors := STON listClass withAll: { 		Color red.		Color red copy setAlpha: 0.4.		Color red lighter lighter }.	self serializeAndMaterialize: colors! !!STONWriteReadTest methodsFor: 'tests'!testSharedColors	| color1 color2 colors |	color1 := Color r: 0.25 g: 0.5 b: 0.75 alpha: 0.4.	color2 := Color red.	colors := STON listClass withAll: { color1. color2. color2 }.	self serializeAndMaterialize: colors! !!STONWriteReadTest methodsFor: 'tests'!testIdentityCollections	| collections |	collections := STON listClass withAll: {		IdentitySet withAll: #(1 2 3).		IdentityDictionary new at: 1 put: 1; at: 2 put: 2; yourself.		IdentityBag withAll: { #A. #B. #A. #B. #A } }.	self serializeAndMaterialize: collections! !!STONWriteReadTest methodsFor: 'tests'!testCustomAssociations	| associations |	associations := OrderedCollection new.	associations add: #foo->100.	associations add: (STONTestAssociation key: #foo value:100).	self serializeAndMaterialize: associations! !!STONWriteReadTest methodsFor: 'tests'!testPrimitives	| primitives |	primitives := STON listClass withAll: { true. false. nil }.	self serializeAndMaterialize: primitives! !!STONWriteReadTest methodsFor: 'tests'!testSmallIntegers	| integers |	integers := STON listClass withAll: (-10 to: 10).	self serializeAndMaterialize: integers! !!STONWriteReadTest methodsFor: 'tests'!testFileSystemSupport	| fileReferences fileLocators |	fileReferences := STON listClass withAll: { 		FileLocator image asFileReference.		FileLocator workingDirectory asFileReference.		(FileLocator home / 'foo.txt') asFileReference }.	self serializeAndMaterialize: fileReferences.	fileLocators := STON listClass withAll: { 		FileLocator image.		FileLocator workingDirectory.		FileLocator home / 'foo.txt' }.	self serializeAndMaterialize: fileLocators.! !!STONWriteReadTest methodsFor: 'tests'!testDomainObject	| object objects |	object := STONTestDomainObject dummy.	self serializeAndMaterialize: object.	objects := STON listClass streamContents: [ :stream |		10 timesRepeat: [ stream nextPut: STONTestDomainObject dummy ] ].	self serializeAndMaterialize: objects.	objects := STON mapClass new.	10 timesRepeat: [ | newObject |		newObject := STONTestDomainObject dummy.		objects at: newObject integer put: newObject ].	self serializeAndMaterialize: objects.! !!STONWriteReadTest methodsFor: 'tests'!testSmallDictionary	"SmallDictionary is special because it does not inherit from Dictionary.	It might also not exist in some dialects, where this test could be skipped."		| dictionaries smallDictionaryClass |	smallDictionaryClass := self environment at: #SmallDictionary ifAbsent: [ Dictionary ].	dictionaries := STON listClass withAll: {		smallDictionaryClass new at: 1 put: 1; at: 2 put: 2; yourself.		smallDictionaryClass new at: 1 put: 1; at: 2 put: 2; yourself.		smallDictionaryClass new }.	self serializeAndMaterialize: dictionaries! !!STONWriteReadTest methodsFor: 'tests'!testJsonMode	| object |	object := STON listClass withAll: {		Float pi.		'Hello World'.		true.		nil.		STON listClass withAll: #( 1 2 3) asByteArray.		STON mapClass new 			at: 'x' put: 1; 			at: 'y' put: 2; 			yourself 	}.	self serializeAndMaterializeJsonMode: object! !!STONWriteReadTest methodsFor: 'tests'!testOrderedDictionary	"OrderedDictionary is special because it does not inherit from Dictionary.	It might also not exist in some dialects, where this test could be skipped."		| dictionaries orderedDictionaryClass orderedIdentityDictionaryClass |	orderedDictionaryClass := self environment at: #OrderedDictionary ifAbsent: [ Dictionary ].	orderedIdentityDictionaryClass := self environment at: #OrderedIdentityDictionary ifAbsent: [ IdentityDictionary ].	dictionaries := STON listClass withAll: {		orderedDictionaryClass new at: 1 put: 1; at: 2 put: 2; yourself.		orderedDictionaryClass new at: #a put: 1; at: #b put: -2; at: #c put: 0; yourself.		orderedDictionaryClass new.		orderedIdentityDictionaryClass new at: 1 put: 1; at: 2 put: 2; yourself.		orderedIdentityDictionaryClass new at: #a put: 1; at: #b put: -2; at: #c put: 0; yourself.		orderedIdentityDictionaryClass new }.	self serializeAndMaterialize: dictionaries! !!STONWriteReadTest methodsFor: 'tests'!testCollectionsStructured	| collections one two |	one := 1@2.	two := 2@3.	collections := STON listClass withAll: {	 	Bag withAll: { one. two. one. two. one }.	 	Set withAll: { one. two. one. two. one }.	 	OrderedCollection withAll: { one. two. one. two. one }.	}.	self serializeAndMaterialize: collections! !!STONWriteReadTest methodsFor: 'tests'!testCharacters	| characters |	characters := STON listClass withAll: ($a to: $z), ($A to: $Z).	self serializeAndMaterialize: characters! !!STONWriteReadTest methodsFor: 'tests'!testUUIDs	| uuids |	uuids := STON listClass withAll: { 		UUID new.		UUID new.		UUID nilUUID }.	self serializeAndMaterialize: uuids! !!STONWriteReadTest methodsFor: 'tests'!testAssociations	| associations |	associations := OrderedCollection new.	1 to: 10 do: [ :each |		associations add: each -> each printString ].	self serializeAndMaterialize: associations! !!STONWriteReadTest methodsFor: 'tests'!testIntervals	| intervals |	intervals := STON listClass withAll: { 		1 to: 10.		1 to: 10 by: 2.		100 to: 50 by: -5 }.	self serializeAndMaterialize: intervals! !!STONWriteReadTest methodsFor: 'tests'!testEmpty	| empty |	empty := STON listClass new.	self serializeAndMaterialize: empty.	empty := STON mapClass new.	self serializeAndMaterialize: empty.! !!STONWriteReadTest methodsFor: 'tests'!testMimeTypes	| mimeTypes |	mimeTypes := STON listClass withAll: { 		ZnMimeType applicationJson.		ZnMimeType textPlain }.	self serializeAndMaterialize: mimeTypes! !!STONWriteReadTest methodsFor: 'tests'!testSymbols	| symbols |	symbols := #( #bytes #'' #Bytes123 ).	self serializeAndMaterialize: symbols.	symbols := Collection allSubclasses collect: [ :each | each name ].	self serializeAndMaterialize: symbols.	"simple symbols"	symbols := #( #foo123 #'123foo' #'punctuation-_./' #'_Foo' #'/root' #'---' #'.st' ).	self serializeAndMaterialize: symbols.	"non-simple symbols"	symbols := #( #'les-élèves-français' #'euro-€' #'ångström' ).	self serializeAndMaterialize: symbols.! !!STONWriteReadTest methodsFor: 'tests'!testURLs	| urls |	urls := STON listClass withAll: { 		'https://pharo.org/files/pharo.png' asUrl. 		'mailto:sven@stfx.eu' asUrl. 		'file:///var/log/system.log' asUrl.		'scheme://user:password@host:123/var/log/system.log?foo=1&bar#frag' asUrl }.	self serializeAndMaterialize: urls! !!STONWriteReadTest methodsFor: 'tests'!testCollections	| collections |	collections := STON listClass withAll: {		#(1 2 3).		OrderedCollection withAll: #(1 2 3).		Set withAll: #(1 2 3).		Bag withAll: #(1 2 2 3).		Dictionary new at: 1 put: 1; at: 2 put: 2; yourself.		#[1 2 3].		#(1 2 3) asIntegerArray.		#(1 2 3) asFloatArray }.	self serializeAndMaterialize: collections! !!STONWriteReadTest methodsFor: 'tests'!testFractions	| fractions |	fractions := STON listClass withAll: (-2/3 to: 2/3 by: 1/3).	self serializeAndMaterialize: fractions! !!STONWriteReadTest methodsFor: 'tests'!testTextAndRunArray	| texts |	texts := { 		'Text!!' asText. 		(Text string: 'I am bold' attribute: TextEmphasis bold), ' and I am normal text'.		Text new }.	self serializeAndMaterialize: texts! !!STONWriteReadTest methodsFor: 'tests'!testClasses	| classes |	classes := STON listClass withAll: { Point. Integer. Object }.	self serializeAndMaterialize: classes.	classes := STON listClass withAll: { Point class. Integer class. Object class }.	self serializeAndMaterialize: classes.	classes := STON listClass withAll: { Class. Metaclass. Class class. Point class class }.	self serializeAndMaterialize: classes.! !!STONWriteReadTest methodsFor: 'tests'!testSpecialCharacters	| primitives |	primitives := STON listClass withAll: { 		String withAll: { Character tab. Character lf. Character cr }.		String withAll: { $'. $". $\. $/ }.		'élèves français'.		'Düsseldorf Königsallee'.		#(1 10 20 30 127 140 150 160 200 255) collect: #asCharacter as: String }.	self serializeAndMaterialize: primitives! !!STONWriteReadTest methodsFor: 'private'!serializeAndMaterialize: object	| serialization materialization |	serialization := self serialize: object.	materialization := self materialize: serialization.	self assert: object equals: materialization	! !!STONWriteReadTest methodsFor: 'private'!serializeJson: anObject	^ String streamContents: [ :stream |		STON jsonWriter 			on: stream;			nextPut: anObject ]! !!STONWriteReadTest methodsFor: 'private'!serializeAndMaterializeJsonMode: object	| serialization materialization |	serialization := self serializeJson: object.	materialization := self materialize: serialization.	self assert: object equals: materialization! !!STONWriteReadTest methodsFor: 'private'!environment	^ Smalltalk globals! !!STONWriteReadTest methodsFor: 'private'!materialize: string	^ STON reader 		on: string readStream;		next! !!STONWriteReadTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream;			nextPut: anObject ]! !STONWriteReadTest subclass: #STONLargeWriteReadTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Write-Read'!!STONLargeWriteReadTest commentStamp: '' prior: 0!STONLargeWriteReadTests test the optimalizations for large structures.!!STONLargeWriteReadTest methodsFor: 'private'!serializeJson: anObject	^ String streamContents: [ :stream |		STON jsonWriter 			on: stream; 			prettyPrint: true;			optimizeForLargeStructures; 			nextPut: anObject ]! !!STONLargeWriteReadTest methodsFor: 'private'!materialize: string	^ STON reader		on: string readStream;		optimizeForLargeStructures;		next! !!STONLargeWriteReadTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream; 			optimizeForLargeStructures; 			nextPut: anObject ]! !STONWriteReadTest subclass: #STONWriteAsciiOnlyReadTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Write-Read'!!STONWriteAsciiOnlyReadTest methodsFor: 'private'!serializeJson: anObject	^ String streamContents: [ :stream |		STON jsonWriter 			on: stream; 			asciiOnly: true;			nextPut: anObject ]! !!STONWriteAsciiOnlyReadTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream; 			asciiOnly: true;			nextPut: anObject ]! !STONWriteReadTest subclass: #STONWritePrettyPrinterReadTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Write-Read'!!STONWritePrettyPrinterReadTest commentStamp: '' prior: 0!STONWritePrettyPrinterReadTests tests pretty printed serialization followed by materialization.!!STONWritePrettyPrinterReadTest methodsFor: 'private'!serializeJson: anObject	^ String streamContents: [ :stream |		STON jsonWriter 			on: stream; 			prettyPrint: true;			nextPut: anObject ]! !!STONWritePrettyPrinterReadTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream; 			prettyPrint: true;			nextPut: anObject ]! !STONWriteReadTest subclass: #STONWriteReadCommentsTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Write-Read'!!STONWriteReadCommentsTest methodsFor: 'private'!materialize: string	^ STON reader		on: (STONCStyleCommentsSkipStream on: string readStream);		optimizeForLargeStructures;		next! !!STONWriteReadCommentsTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		stream << '/* initial comment */'.		STON writer 			on: stream;			nextPut: anObject.		stream << '/* final comment */' ]! !TestCase subclass: #STONWriterTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Writer'!!STONWriterTest commentStamp: '' prior: 0!STONWriterTests test serialization.!!STONWriterTest methodsFor: 'private'!serializeJson: anObject	^ String streamContents: [ :stream |		STON jsonWriter 			on: stream; 			nextPut: anObject ]! !!STONWriterTest methodsFor: 'private'!serializeAsciiOnly: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream;			asciiOnly: true;			nextPut: anObject ]! !!STONWriterTest methodsFor: 'private'!serializePretty: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream; 			prettyPrint: true;			nextPut: anObject ]! !!STONWriterTest methodsFor: 'private'!serialize: anObject	^ String streamContents: [ :stream |		STON writer 			on: stream;			nextPut: anObject ]! !!STONWriterTest methodsFor: 'tests'!testOrderedCollection	| collection |	collection := OrderedCollection with: 1 with: 2 with: 3.	self assert: (self serialize: collection) equals: 'OrderedCollection[1,2,3]'.	self assert: (self serialize: OrderedCollection new) equals: 'OrderedCollection[]'! !!STONWriterTest methodsFor: 'tests'!testFloat	self assert: (self serialize: 1.5) equals: '1.5'.	self assert: (self serialize: 0.0) equals: '0.0'.	self assert: (self serialize: -1.5) equals: '-1.5'.	self assert: ((self serialize: Float pi) beginsWith: '3.14159').	self assert: ((self serialize: (1 / 3) asFloat) beginsWith: '0.333').	self assert: (self serialize: (10 raisedTo: 100) asFloat) equals: '1.0e100'.	self assert: (self serialize: (10 raisedTo: -50) asFloat) equals: '1.0e-50'.	self assert: (self serialize: (10 raisedTo: -50) asFloat negated) equals: '-1.0e-50'! !!STONWriterTest methodsFor: 'tests'!testSymbol	self assert: (self serialize: #foo) equals: '#foo'.	self assert: (self serialize: #FOO) equals: '#FOO'.	self assert: (self serialize: #bytes) equals: '#bytes'.	self assert: (self serialize: #'foo.bar') equals: '#foo.bar'.	self assert: (self serialize: #'foo-bar') equals: '#foo-bar'.	self assert: (self serialize: #foo_bar) equals: '#foo_bar'.	self assert: (self serialize: #'foo/bar') equals: '#foo/bar'.	self assert: (self serialize: #'foo bar') equals: '#''foo bar'''.	self assert: (self serialize: #foo123) equals: '#foo123'! !!STONWriterTest methodsFor: 'tests'!testClass	self assert: (self serialize: Point) equals: 'Class[#Point]'! !!STONWriterTest methodsFor: 'tests'!testCustomNewline	| output |	output := String streamContents: [ :out |		(STON writer on: out)			newLine: String lf;			prettyPrint: true;			nextPut: #( 1 ) ].	self 		assert: output 		equals: ('[\	1\]' withCRs replaceAll: Character cr with: Character lf)! !!STONWriterTest methodsFor: 'tests'!testIsSimpleSymbol	self assert: (STON writer isSimpleSymbol: #foo).	self assert: (STON writer isSimpleSymbol: #az).	self assert: (STON writer isSimpleSymbol: #AZ).	self assert: (STON writer isSimpleSymbol: #N0123456789).	self assert: (STON writer isSimpleSymbol: #foo123).	self assert: (STON writer isSimpleSymbol: #'Foo/Bar').	self assert: (STON writer isSimpleSymbol: #'Foo.Bar').	self assert: (STON writer isSimpleSymbol: #'Foo-Bar').	self assert: (STON writer isSimpleSymbol: #'Foo_Bar').	self assert: (STON writer isSimpleSymbol: #foo).	self deny: (STON writer isSimpleSymbol: #'#^&$%')! !!STONWriterTest methodsFor: 'tests'!testTime	| time |	time := Time hour: 6 minute: 30 second: 15.	self assert: (self serialize: time) equals: 'Time[''06:30:15'']'.	time := Time hour: 6 minute: 30 second: 15 nanoSecond: 123.	self assert: (self serialize: time) equals: 'Time[''06:30:15.000000123'']'.! !!STONWriterTest methodsFor: 'tests'!testSymbolAsString	self assert: (self serializeJson: #foo) equals: '"foo"'.	self assert: (self serializeJson: #FOO) equals: '"FOO"'! !!STONWriterTest methodsFor: 'tests'!testNil	self assert: (self serialize: nil) equals: 'nil'! !!STONWriterTest methodsFor: 'tests'!testUser2	| user |	(user := STONTestUser2 new)		username: 'john@foo.com';		password: 'secret1'.	self 		assert: (self serialize: user)		equals: 'TestUser2{#username:''john@foo.com'',#password:''secret1'',#enabled:true}'! !!STONWriterTest methodsFor: 'tests'!testMetaclass	self assert: (self serialize: Point class) equals: 'Metaclass[#Point]'! !!STONWriterTest methodsFor: 'tests'!testDiskFile	self assert: (self serialize: 'foo.txt' asFileReference) equals: 'FILE[''foo.txt'']'.	self assert: (self serialize: '/tmp/foo.txt' asFileReference) equals: 'FILE[''/tmp/foo.txt'']'.	self assert: (self serialize: 'tmp/foo.txt' asFileReference) equals: 'FILE[''tmp/foo.txt'']'.	self assert: (self serialize: '/tmp' asFileReference) equals: 'FILE[''/tmp'']'.	self assert: (self serialize: '/tmp/' asFileReference) equals: 'FILE[''/tmp'']'.! !!STONWriterTest methodsFor: 'tests'!testKeepingNewLines	| input result output |	input := 'line ending with CR', String cr, 		'line ending with LF', String lf, 		'line ending with CRLF', String crlf.	output := '''line ending with CR', String crlf, 		'line ending with LF', String crlf, 		'line ending with CRLF', String crlf, ''''.	result := String streamContents: [ :out |		(STON writer on: out) newLine: String crlf; keepNewLines: true; nextPut: input ].	self assert: result equals: output.	output := '''line ending with CR', String cr, 		'line ending with LF', String cr, 		'line ending with CRLF', String cr, ''''.	result := String streamContents: [ :out |		(STON writer on: out) newLine: String cr; keepNewLines: true; nextPut: input ].	self assert: result equals: output! !!STONWriterTest methodsFor: 'tests'!testScaledDecimal	self assert: (self serialize: 1/3s2) equals: '1/3s2'.	self assert: (self serialize: -1/3s2) equals: '-1/3s2'.	self assert: (self serialize: 1/3s10) equals: '1/3s10'.	self assert: (self serialize: -1/3s10) equals: '-1/3s10'.! !!STONWriterTest methodsFor: 'tests'!testColor	self 		assert: (self serialize: Color red) 		equals: 'Color[#red]'.	self 		assert: (self serialize: (Color red copy setAlpha: 0.4)) 		equals: 'Color{#red:1.0,#green:0.0,#blue:0.0,#alpha:0.4}'.	self 		assert: (self serialize: Color red lighter lighter) 		equals: 'Color{#red:1.0,#green:0.061,#blue:0.061,#alpha:1.0}'.! !!STONWriterTest methodsFor: 'tests'!testAssociation	self assert: (self serialize: 'foo' -> 1) equals: '''foo'':1'.	self assert: (self serialize: #bar -> 2) equals: '#bar:2'.	self assert: (self serialize: 'foo bar' -> #ok) equals: '''foo bar'':#ok'.	self assert: (self serialize: 123 -> 456) equals: '123:456'! !!STONWriterTest methodsFor: 'tests'!testMimeType	self		assert: (self serialize: ZnMimeType applicationJson)		equals: 'MimeType[''application/json'']'.	self		assert: (self serialize: ZnMimeType textPlain)		equals: 'MimeType[''text/plain;charset=utf-8'']'.! !!STONWriterTest methodsFor: 'tests'!testDictionary	| collection |	collection := STON mapClass new		at: 1 put: 1;		at: 2 put: 2;		yourself.	self assert: (self serialize: collection) equals: '{1:1,2:2}'.	self assert: (self serialize: STON mapClass new) equals: '{}'! !!STONWriterTest methodsFor: 'tests'!testDateAndTime	| dateAndTime |	dateAndTime := DateAndTime		year: 2012		month: 1		day: 1		hour: 6		minute: 30		second: 15		offset: 1 hour.	self assert: (self serialize: dateAndTime) equals: 'DateAndTime[''2012-01-01T06:30:15+01:00'']'! !!STONWriterTest methodsFor: 'tests'!testFraction	self assert: (self serialize: 1/3) equals: '1/3'.	self assert: (self serialize: -1/3) equals: '-1/3'.	self assert: (self serialize: 10/100) equals: '1/10'.	self assert: (self serialize: 100/10) equals: '10'.	self assert: (self serialize: 123/123) equals: '1'.	self assert: (self serialize: 100/11) equals: '100/11'.! !!STONWriterTest methodsFor: 'tests'!testUser3Nil	| user |	user := STONTestUser3 new.	self 		assert: (self serialize: user) 		equals: 'TestUser3{#username:nil,#password:nil,#enabled:true}'! !!STONWriterTest methodsFor: 'tests'!testEmptyArrayPretty	self assert: (self serializePretty: STON listClass new) equals: '[ ]' ! !!STONWriterTest methodsFor: 'tests'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(STON writer on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '''\uD834\uDD1E'''! !!STONWriterTest methodsFor: 'tests'!testInteger	self assert: (self serialize: 1) equals: '1'.	self assert: (self serialize: 0) equals: '0'.	self assert: (self serialize: -1) equals: '-1'.	self assert: (self serialize: 1234567890) equals: '1234567890'.	self assert: (self serialize: -1234567890) equals: '-1234567890'! !!STONWriterTest methodsFor: 'tests'!testUser	| user |	(user := STONTestUser new)		username: 'john@foo.com';		password: 'secret1'.	self 		assert: (self serialize: user)		equals: 'TestUser{#username:''john@foo.com'',#password:''secret1'',#enabled:true}'! !!STONWriterTest methodsFor: 'tests'!testBag	self 		assert: (self serialize: (Bag withAll: #(a a)))		equals: 'Bag{#a:2}'.	self 		assert: (self serialize: Bag new)		equals: 'Bag{}'! !!STONWriterTest methodsFor: 'tests'!testString	| string |	self assert: (self serialize: 'foo') equals: '''foo'''.	self assert: (self serialize: 'FOO') equals: '''FOO'''.	self assert: (self serializeAsciiOnly: 'élève en Français') equals: '''\u00E9l\u00E8ve en Fran\u00E7ais'''.	self assert: (self serialize: 'élève en Français') equals: '''élève en Français'''.	string := String withAll: {$" . $' . $\ . $/ . Character tab . Character cr . Character lf . Character newPage . Character backspace}.	self assert: (self serialize: string) equals: '''"\''\\/\t\r\n\f\b'''! !!STONWriterTest methodsFor: 'tests'!testBoolean	self assert: (self serialize: true) equals: 'true'.	self assert: (self serialize: false) equals: 'false'! !!STONWriterTest methodsFor: 'tests'!testUserNil	| user |	user := STONTestUser new.	self assert: (self serialize: user) equals: 'TestUser{#enabled:true}'! !!STONWriterTest methodsFor: 'tests'!testByteArray	self assert: (self serialize: #(1 2 3) asByteArray) equals: 'ByteArray[''010203'']'! !!STONWriterTest methodsFor: 'tests'!testPoint	self assert: (self serialize: 1 @ 2) equals: 'Point[1,2]'! !!STONWriterTest methodsFor: 'tests'!testMap	| map |	(map := STON mapClass new)		at: #foo put: 1;		at: #bar put: 2.	self assert: (self serialize: map) equals: '{#foo:1,#bar:2}'.	self assert: (self serialize: STON mapClass new) equals: '{}'.	map removeAll.	map at: 'foo bar' put: #ok.	self assert: (self serialize: map) equals: '{''foo bar'':#ok}'.	map removeAll.	map at: 123 put: 456.	self assert: (self serialize: map) equals: '{123:456}'! !!STONWriterTest methodsFor: 'tests'!testReferenceCycle	| array |	array := STON listClass with: 1 with: nil.	array at: 2 put: array.	self assert: (self serialize: array) equals: '[1,@1]'! !!STONWriterTest methodsFor: 'tests'!testReferenceSharingIgnore	| serializer array one |	serializer := [ :object | 	String		streamContents: [ :stream | 			STON writer				on: stream;				referencePolicy: #ignore;				nextPut: object ] ].	one := {#one}.	array := STON listClass with: one with: one with: one.	self assert: (serializer value: array) equals: '[[#one],[#one],[#one]]'! !!STONWriterTest methodsFor: 'tests'!testDictionaryWithComplexKeys	| collection |	collection := STON mapClass new at: true put: 1; at: #(foo) put: 2; yourself.	self assert: (#('{true:1,[#foo]:2}' '{[#foo]:2,true:1}') includes: (self serialize: collection))! !!STONWriterTest methodsFor: 'tests'!testNull	self assert: (self serializeJson: nil) equals: 'null'! !!STONWriterTest methodsFor: 'tests'!testIdentityDictionary	| collection |	collection := IdentityDictionary new		at: 1 put: 1;		at: 2 put: 2;		yourself.	self assert: (self serialize: collection) equals: 'IdentityDictionary{1:1,2:2}'.	self assert: (self serialize: IdentityDictionary new) equals: 'IdentityDictionary{}'! !!STONWriterTest methodsFor: 'tests'!testReferenceSharing	| array one |	one := {#one}.	array := STON listClass with: one with: one with: one.	self assert: (self serialize: array) equals: '[[#one],@2,@2]'! !!STONWriterTest methodsFor: 'tests'!testDoubleQuotedString	| string |	self assert: (self serializeJson: 'foo') equals: '"foo"'.	self assert: (self serializeJson: 'FOO') equals: '"FOO"'.	self assert: (self serializeJson: 'élève en Français') equals: '"élève en Français"'.	string := String withAll: {$" . $' . $\ . $/ . Character tab . Character cr . Character lf . Character newPage . Character backspace}.	"Note that in JSON mode, double quotes get escaped, and single quotes not"	self assert: (self serializeJson: string) equals: '"\"''\\/\t\r\n\f\b"'! !!STONWriterTest methodsFor: 'tests'!testList	self assert: (self serialize: (STON listClass withAll: #(1 2 3))) equals: '[1,2,3]'.	self assert: (self serialize: STON listClass new) equals: '[]'.	self assert: (self serialize: (STON listClass withAll: {1 . -1 . 0 . #foo . 'a b c' . true . false . nil})) equals: '[1,-1,0,#foo,''a b c'',true,false,nil]'! !!STONWriterTest methodsFor: 'tests'!testRestrictedClassesInJsonMode	self should: [ self serializeJson: 1@2 ] raise: STONWriterError.	self should: [ self serializeJson: #foo->100 ] raise: STONWriterError.	self should: [ self serializeJson: STONTestUser dummy ] raise: STONWriterError.! !!STONWriterTest methodsFor: 'tests'!testReferenceSharingError	| serializer array one |	serializer := [ :object | 		String streamContents: [ :stream |			STON writer 				on: stream;				referencePolicy: #error; 				nextPut: object ] ].	one := { #one }.	array := STON listClass with: one with: one with: one.	self 		should: [ (serializer value: array) = '[[#one],[#one],[#one]]' ] 		raise: STONWriterError! !!STONWriterTest methodsFor: 'tests'!testURL	self		assert: (self serialize: 'https://pharo.org/files/pharo.png' asUrl)		equals: 'URL[''https://pharo.org/files/pharo.png'']'.	self		assert: (self serialize: 'mailto:sven@stfx.eu' asUrl)		equals: 'URL[''mailto:sven@stfx.eu'']'.	self		assert: (self serialize: 'file:///var/log/system.log' asUrl)		equals: 'URL[''file:///var/log/system.log'']'.	self		assert: (self serialize: 'scheme://user:password@host:123/var/log/system.log?foo=1&bar#frag' asUrl)		equals: 'URL[''scheme://user:password@host:123/var/log/system.log?foo=1&bar#frag'']'.! !!STONWriterTest methodsFor: 'tests'!testDate	| date |	date := (Date year: 2012 month: 1 day: 1) translateToUTC.	self assert: (self serialize: date) equals: 'Date[''2012-01-01Z'']'.	date := (Date year: 2012 month: 1 day: 1) translateTo: 1 hour.	self assert: (self serialize: date) equals: 'Date[''2012-01-01+01:00'']'.! !!STONWriterTest methodsFor: 'tests'!testEmptyDictionaryPretty	self assert: (self serializePretty: STON mapClass new) equals: '{ }' ! !Association subclass: #STONTestAssociation	instanceVariableNames: 'timestamp'	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestAssociation commentStamp: '' prior: 0!STONTestAssociation is used to support unit tests.!!STONTestAssociation methodsFor: 'accessing'!now	^ DateAndTime now! !!STONTestAssociation methodsFor: 'accessing'!key: aKey value: anObject 	super key: aKey value: anObject.	timestamp := self now! !!STONTestAssociation methodsFor: 'accessing'!timestamp	^ timestamp! !!STONTestAssociation methodsFor: 'accessing'!value: anObject	super value: anObject.	timestamp := self now! !Object subclass: #STONTestDomainObject	instanceVariableNames: 'created modified integer float description color tags bytes boolean'	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestDomainObject commentStamp: '' prior: 0!STONTestDomainObject is used to support unit tests.Instance Variables	boolean:		<Boolean>	bytes:			<ByteArray>	color:			<Symbol>	created:		<DateAndTime>	description:	<String>	float:			<Float>	integer:		<Integer>	modified:	<DateAndTime>	tags:			<Array of: Symbol>!!STONTestDomainObject methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ color = anObject color		and: [ 			modified = anObject modified				and: [ 					created = anObject created						and: [ 							description = anObject description								and: [ 									boolean = anObject boolean										and: [ 											(float closeTo: anObject float) 		"Use #closeTo: instead of #= to increase portability"												and: [ 													bytes = anObject bytes 														and: [ 															integer = anObject integer 																and: [ tags = anObject tags ] ] ] ] ] ] ] ]! !!STONTestDomainObject methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ color hash		bitXor:			(modified hash				bitXor:					(created hash						bitXor:							(description hash								bitXor: (boolean hash bitXor: (float hash bitXor: (bytes hash bitXor: (integer hash bitXor: tags hash)))))))! !!STONTestDomainObject methodsFor: 'initialize-release'!initialize	created := modified := DateAndTime now.! !!STONTestDomainObject methodsFor: 'accessing'!bytes: anObject	bytes := anObject! !!STONTestDomainObject methodsFor: 'accessing'!boolean: anObject	boolean := anObject! !!STONTestDomainObject methodsFor: 'accessing'!description	^ description! !!STONTestDomainObject methodsFor: 'accessing'!modified: anObject	modified := anObject! !!STONTestDomainObject methodsFor: 'accessing'!description: anObject	description := anObject! !!STONTestDomainObject methodsFor: 'accessing'!integer: anObject	integer := anObject! !!STONTestDomainObject methodsFor: 'accessing'!color: anObject	color := anObject! !!STONTestDomainObject methodsFor: 'accessing'!color	^ color! !!STONTestDomainObject methodsFor: 'accessing'!tags	^ tags! !!STONTestDomainObject methodsFor: 'accessing'!bytes	^ bytes! !!STONTestDomainObject methodsFor: 'accessing'!float	^ float! !!STONTestDomainObject methodsFor: 'accessing'!tags: anObject	tags := anObject! !!STONTestDomainObject methodsFor: 'accessing'!float: anObject	float := anObject! !!STONTestDomainObject methodsFor: 'accessing'!modified	^ modified! !!STONTestDomainObject methodsFor: 'accessing'!created: anObject	created := anObject! !!STONTestDomainObject methodsFor: 'accessing'!integer	^ integer! !!STONTestDomainObject methodsFor: 'accessing'!created	^ created! !!STONTestDomainObject methodsFor: 'accessing'!boolean	^ boolean! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestDomainObject class	instanceVariableNames: ''!!STONTestDomainObject class methodsFor: 'ston-core'!stonName	^ #TestDomainObject! !!STONTestDomainObject class methodsFor: 'instance creation'!dummy	^ self new		integer: 999999 atRandom;		float: 999 atRandom / Float pi;		boolean: #(true false) atRandom;		bytes: (ByteArray streamContents: [ :out | 32 timesRepeat: [ out nextPut: 255 atRandom ] ]);		description: (String streamContents: [ :out | 16 atRandom timesRepeat: [ out nextPutAll: 'Blah' ] ]);		color: #(#red #green #blue) atRandom;		tags: (Array 			with: #(#one #two #three) atRandom 			with: #(#alpha #beta #gamma) atRandom 			with: #(#low #medium #high) atRandom);		yourself! !Object subclass: #STONTestKnownObject	instanceVariableNames: 'id description'	classVariableNames: 'KnownObjects'	package: 'STON-Tests-Support'!!STONTestKnownObject commentStamp: '' prior: 0!I am STONTestKnownObject. I support unit tests.I have an id and a description.When I am serialized, only my id is written out.  STONTestKnownObject['bb71b026-180c-0d00-b40c-38700aee7555']When I am materialized, the id is used to reconstruct the object, either by retrieving it from a collection of known objects, or it is created (it could also be a retrieval from somewhere else).I keep a collection of all my known instances, new instances are added to it automatically.Use my class side's #fromId: to access existing instances!!STONTestKnownObject methodsFor: 'comparing'!= object	self class == object class ifFalse: [ ^ false ].	^ self id = object id! !!STONTestKnownObject methodsFor: 'comparing'!hash	^ self id hash! !!STONTestKnownObject methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: id; nextPut: $)! !!STONTestKnownObject methodsFor: 'accessing'!description	^ description! !!STONTestKnownObject methodsFor: 'accessing'!id	^ id! !!STONTestKnownObject methodsFor: 'initalize'!description: string	description := string! !!STONTestKnownObject methodsFor: 'initalize'!id: uuid	id := uuid.	self description: 'I am a complex object known under the ID ', id asString, ' - I was created @ ', DateAndTime now asString! !!STONTestKnownObject methodsFor: 'initalize'!initialize	super initialize.	self id: UUID new.	self class addKnownObject: self! !!STONTestKnownObject methodsFor: 'ston-core'!stonOn: stonWriter	"We only write out our id"		stonWriter writeObject: self listSingleton: self id asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestKnownObject class	instanceVariableNames: ''!!STONTestKnownObject class methodsFor: 'instance creation'!fromId: idString	"Given id, return a matching instance of me, either by returning an existing known instance or by creating a new one (that is automtically added to the known instances)"		| uuid |	uuid := UUID fromString: idString.	^ self knownObjects 		detect: [ :each | each id = uuid ] 		ifNone: [ self new id: uuid ]! !!STONTestKnownObject class methodsFor: 'ston-core'!fromSton: stonReader	^ self fromId: stonReader parseListSingleton! !!STONTestKnownObject class methodsFor: 'acccessing'!resetKnownObjects	KnownObjects ifNotNil: [ :collection | collection removeAll ]! !!STONTestKnownObject class methodsFor: 'acccessing'!addKnownObject: object	^ self knownObjects addIfNotPresent: object! !!STONTestKnownObject class methodsFor: 'acccessing'!knownObjects	^ KnownObjects ifNil: [ KnownObjects := OrderedCollection new ]! !Dictionary subclass: #STONTestMap	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestMap commentStamp: '' prior: 0!STONTestMap is used to support unit tests.I am a Dictionary but I don't print my elements during #printOn: to allow safe inspection of structures containing cycles that would otherwise lead to infinite loops.!!STONTestMap methodsFor: 'printing'!printElementsOn: stream	stream		nextPut: $(;		nextPut: $#;		print: self size;		nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestMap class	instanceVariableNames: ''!!STONTestMap class methodsFor: 'instance creation'!classTree: topClass	| map |	map := IdentityDictionary new.	topClass withAllSubclasses do: [ :eachClass | | info |		(info := self new)			at: #name put: eachClass name asString;			at: #comment put: eachClass comment;			at: #isMeta put: eachClass isMeta;			at: #methods put: eachClass selectors.				map at: eachClass put: info ].	map keysAndValuesDo: [ :eachClass :eachInfo |		eachClass == topClass			ifFalse: [ eachInfo at: #superclass put: (map at: eachClass superclass) ].		eachInfo at: #subclasses put: (eachClass subclasses collect: [ :subClass | map at: subClass ]) ].	^ map at: topClass! !!STONTestMap class methodsFor: 'instance creation'!classTreeExtended: topClass	| map |	map := IdentityDictionary new.	topClass withAllSubclasses do: [ :eachClass | | info methodsInfo |		(info := self new)			at: #name put: eachClass name asString;			at: #comment put: eachClass comment;			at: #isMeta put: eachClass isMeta;			at: #methods put: (methodsInfo := self new).		eachClass methods do: [ :eachMethod | | methodInfo |			(methodInfo := self new)				at: #name put: eachMethod selector;				at: #numArgs put: eachMethod numArgs;				at: #class put: info.			methodsInfo at: eachMethod selector put: methodInfo ].		map at: eachClass put: info ].	map keysAndValuesDo: [ :eachClass :eachInfo |		eachClass == topClass 			ifFalse: [ eachInfo at: #superclass put: (map at: eachClass superclass) ].		eachInfo at: #subclasses put: (eachClass subclasses collect: [ :subClass | map at: subClass ]) ].	^ map at: topClass! !!STONTestMap class methodsFor: 'instance creation'!classTreeExtended	^ self classTreeExtended: Object! !!STONTestMap class methodsFor: 'instance creation'!classTree	^ self classTree: Object! !!STONTestMap class methodsFor: 'ston-core'!stonName	^ #TestMap! !Object subclass: #STONTestUser	instanceVariableNames: 'username password enabled'	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestUser commentStamp: '' prior: 0!STONTestUser is used to support unit tests.Instance Variables	enabled:		<Boolean>	password:	<String>	username:	<String>!!STONTestUser methodsFor: 'accessing'!enabled	^ enabled! !!STONTestUser methodsFor: 'accessing'!password	^ password! !!STONTestUser methodsFor: 'accessing'!enabled: anObject	enabled := anObject! !!STONTestUser methodsFor: 'accessing'!username: anObject	username := anObject! !!STONTestUser methodsFor: 'accessing'!username	^ username! !!STONTestUser methodsFor: 'accessing'!password: anObject	password := anObject! !!STONTestUser methodsFor: 'initialize-release'!initialize 	super initialize.	enabled := true! !!STONTestUser methodsFor: 'comparing'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ username = anObject username and: [ password = anObject password and: [ enabled = anObject enabled ] ]! !!STONTestUser methodsFor: 'comparing'!hash	"Answer an integer value that is related to the identity of the receiver."	^ username hash bitXor: (password hash bitXor: enabled hash)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestUser class	instanceVariableNames: ''!!STONTestUser class methodsFor: 'ston-core'!stonName	^ #TestUser! !!STONTestUser class methodsFor: 'instance creation'!dummy	"self dummy"		| username password |	username := String streamContents: [ :stream |		stream << 'user'; print: 999 atRandom; << '@company'; print: 99 atRandom; << '.com' ].	password := String streamContents: [ :stream |		stream << 'secret'; print: 999 atRandom ].	^ self new		username: username;		password: password;		yourself! !STONTestUser subclass: #STONTestUser2	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestUser2 commentStamp: '' prior: 0!STONTestUser2 extends STONTestUser with explicit implementations of #fromSton: and #stonOn:!!STONTestUser2 methodsFor: 'ston-core'!fromSton: stonReader	stonReader parseMapDo: [ :key :value |		key = #username ifTrue: [ username := value ].		key = #password ifTrue: [ password := value ].		key = #enabled ifTrue: [ enabled := value ] ]	! !!STONTestUser2 methodsFor: 'ston-core'!stonOn: stonWriter		stonWriter writeObject: self streamMap: [ :dictionary |		dictionary			at: #username put: username;			at: #password put: password;			at: #enabled put: enabled ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestUser2 class	instanceVariableNames: ''!!STONTestUser2 class methodsFor: 'ston-core'!stonName	^ #TestUser2! !STONTestUser subclass: #STONTestUser3	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Support'!!STONTestUser3 commentStamp: '' prior: 0!STONTestUser3 extends STONTestUser but wants nil instance variables to be written!!STONTestUser3 methodsFor: 'ston-core'!stonShouldWriteNilInstVars	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTestUser3 class	instanceVariableNames: ''!!STONTestUser3 class methodsFor: 'ston-core'!stonAllInstVarNames	^ #(username password enabled)! !!STONTestUser3 class methodsFor: 'ston-core'!stonName	^ #TestUser3! !TestCase subclass: #STONJSONTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Facade'!!STONJSONTest commentStamp: '' prior: 0!STONJSONTests contains unit tests for the JSON functionality available in STON.!!STONJSONTest methodsFor: 'tests'!testShared	"Structure sharing cannot be encoded using JSON"	self		should: [ | foo |			foo := { 'foo'->'dummy' } asDictionary.			STONJSON toString: { foo. foo } ]		raise: STONWriterError! !!STONJSONTest methodsFor: 'tests'!testNull	self assert: (STONJSON toString: nil) equals: 'null'.	self assert: (STONJSON fromString: 'null') equals: nil.! !!STONJSONTest methodsFor: 'tests'!testLists	self assert: (STONJSON toString: #(1 2 3)) equals: '[1,2,3]'.	self assert: (STONJSON toString: #(1 -2 true 3 nil)) equals: '[1,-2,true,3,null]'.	self assert: (STONJSON toString: #(1 (2) 3)) equals: '[1,[2],3]'.	self assert: (STONJSON toString: #()) equals: '[]'.	self assert: (STONJSON fromString: '[]') equals: #().	self assert: (STONJSON fromString: '[1,2,3]') equals: #(1 2 3).	self assert: (STONJSON fromString: '[1,-2,true,3,null]') equals: #(1 -2 true 3 nil).	self assert: (STONJSON fromString: '[1,[2],3]') equals: #(1 (2) 3).! !!STONJSONTest methodsFor: 'tests'!testIntegers	self assert: (STONJSON toString: 1) equals: '1'.	self assert: (STONJSON toString: 0) equals: '0'.	self assert: (STONJSON toString: -1) equals: '-1'.	self assert: (STONJSON toString: 1234567890) equals: '1234567890'.	self assert: (STONJSON fromString: '1') equals: 1.	self assert: (STONJSON fromString: '0') equals: 0.	self assert: (STONJSON fromString: '-1') equals: -1.	self assert: (STONJSON fromString: '1234567890') equals: 1234567890.! !!STONJSONTest methodsFor: 'tests'!testCircular	"Circular datastructures cannot be encoded using JSON"	self		should: [ | foo |			foo := { 'foo'->'dummy' } asDictionary.			foo at: 'bar' put: foo.			STONJSON toString: foo ]		raise: STONWriterError! !!STONJSONTest methodsFor: 'tests'!testBooleans	self assert: (STONJSON toString: true) equals: 'true'.	self assert: (STONJSON toString: false) equals: 'false'.	self assert: (STONJSON fromString: 'true') equals: true.	self assert: (STONJSON fromString: 'false') equals: false.! !!STONJSONTest methodsFor: 'tests'!testOrderedDictionary	| odictClass odict json dict |	odictClass := Smalltalk at: #OrderedDictionary ifAbsent: [ ^ self skip ].	odict := odictClass newFrom: {('a' -> 42) . ('b' -> 1) . ('aa' -> 4) . ('c' -> 23)}.	"assert that the order is not equal in the dictionary hash table"	self		assertCollection: odict asArray hasSameElements: odict dictionary asArray;		deny: odict asArray equals: odict dictionary asArray.	"ordered presevered when encoding:"	json := STONJSON toString: odict.	self assert: json equals: '{"a":42,"b":1,"aa":4,"c":23}'.	"lost when decoding"	dict := STONJSON fromString: json.	self		assertCollection: dict asArray hasSameElements: odict asArray;		assert: dict equals: odict dictionary;		deny: dict asArray equals: odict asArray! !!STONJSONTest methodsFor: 'tests'!testUnknown	"Only Array for lists and Dictionary for maps are allowed for JSON encoding,	any other Smalltalk object cannot be encoded (following the specs).	Even considering all collections to be lists won't work because the type 	is then lost when decoding"		self should: [ STONJSON toString: 1@2 ] raise: STONWriterError.	self should: [ STONJSON toString: #(1 2 3) asOrderedCollection ] raise: STONWriterError.! !!STONJSONTest methodsFor: 'tests'!testFloats	self assert: (STONJSON toString: 1.0) equals: '1.0'.	self assert: (STONJSON toString: 0.0) equals: '0.0'.	self assert: (STONJSON toString: -1.0) equals: '-1.0'.	self assert: (STONJSON toString: -1.23456e-6) equals: '-1.23456e-6'.	self assert: ((STONJSON fromString: '1.0') closeTo: 1.0).	self assert: ((STONJSON fromString: '0.0') closeTo: 0.0).	self assert: ((STONJSON fromString: '-1.0') closeTo: -1.0).	self assert: ((STONJSON fromString: '-1.23456e-6') closeTo: -1.23456e-6).! !!STONJSONTest methodsFor: 'tests'!testStrings	self assert: (STONJSON toString: 'string') equals: '"string"'.	self assert: (STONJSON toString: '') equals: '""'.	self assert: (STONJSON toString: 'élèves français') equals: '"élèves français"'.	self assert: (STONJSON toString: String crlf) equals: '"\r\n"'.	self assert: (STONJSON fromString: '"string"') equals: 'string'.	self assert: (STONJSON fromString: '""') equals: ''.	self assert: (STONJSON fromString: '"élèves français"') equals: 'élèves français'.	self 		assert: (STONJSON fromString: '"\u212B \"Angstrom Symbol\""') 		equals: 8491 asCharacter asString, ' "Angstrom Symbol"'.! !!STONJSONTest methodsFor: 'tests'!testMaps	self assert: (STONJSON toString: { 'temperature'->37 } asDictionary) equals: '{"temperature":37}'.	self assert: (STONJSON toString: Dictionary new) equals: '{}'.	self assert: (STONJSON fromString: '{"temperature":37}') equals: { 'temperature'->37 } asDictionary.	self assert: (STONJSON fromString: '{}') equals: Dictionary new.! !TestCase subclass: #STONTest	instanceVariableNames: ''	classVariableNames: ''	package: 'STON-Tests-Facade'!!STONTest commentStamp: '' prior: 0!STONTests tests the API offered by STON.!!STONTest methodsFor: 'tests'!testRoomExitCycles	| model room1 room2 exit1 exit2 ston object |	(room1 := STONTestMap new) at: #name put: 'Room 1'.	(room2 := STONTestMap new) at: #name put: 'Room 2'.	(exit1 := STONTestMap new)		at: #name put: 'Exit 1';		at: #origin put: room1;		at: #destination put: room2.	(exit2 := STONTestMap new)		at: #name put: 'Exit 2';		at: #origin put: room2;		at: #destination put: room1.	room1 at: #exit put: exit1.	room2 at: #exit put: exit2.	model := Array with: room1 with: room2.	ston := STON toString: model.	object := STON fromString: ston.	"We can't just compare because this is a recursive datastructure"	self assert: (object first at: #name) equals: 'Room 1'.	self assert: (object second at: #name) equals: 'Room 2'.	self assert: ((object first at: #exit) at: #name) equals: 'Exit 1'.	self assert: ((object second at: #exit) at: #name) equals: 'Exit 2'.	self assert: ((object first at: #exit) at: #origin) identicalTo: object first.	self assert: ((object first at: #exit) at: #destination) identicalTo: object second.	self assert: ((object second at: #exit) at: #origin) identicalTo: object second.	self assert: ((object second at: #exit) at: #destination) identicalTo: object first.	"Try writing again the parse model"	self assert: (STON toString: object) equals: ston! !!STONTest methodsFor: 'tests'!testFromStringWithComments	| object |	object := STON listClass withAll: { 1. 0. -1. true. false. nil }.	self 		assert: (STON fromStringWithComments: '// comment\[1, /* comment */ 0, -1, true, false, nil] // comment' withCRs)		equals: object! !!STONTest methodsFor: 'tests'!testPrettyPrinting	| object |	object := STONTestUser dummy.	self assert: (STON fromString: (STON toStringPretty: object)) equals: object.	object := STONTestDomainObject dummy.	self assert: (STON fromString: (STON toStringPretty: object)) equals: object! !!STONTest methodsFor: 'tests'!testFromString	| object |	object := STON listClass withAll: {1 . 0 . -1 . true . false . nil}.	self assert: (STON fromString: '[1,0,-1,true,false,nil]') equals: object! !!STONTest methodsFor: 'tests'!testToString	| object |	object := STON listClass withAll: {1 . 0 . -1 . true . false . nil}.	self assert: (STON toString: object) equals: '[1,0,-1,true,false,nil]'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!STONTest class	instanceVariableNames: ''!!STONTest class methodsFor: 'utilities'!write: object toFileNamed: path	^ path asFileReference		writeStreamDo: [ :stream | 			STON writer				on: stream;				nextPut: object ]! !!STONTest class methodsFor: 'utilities'!fastWrite: object toFileNamed: path	^ path asFileReference		writeStreamDo: [ :fileStream | 			ZnBufferedWriteStream				on: fileStream				do: [ :stream | 					STON writer						on: stream;						optimizeForLargeStructures;						nextPut: object ] ]! !!STONTest class methodsFor: 'utilities'!fastReadFromFileNamed: path	^ path asFileReference		readStreamDo: [ :stream | 			STON reader				on: (ZnBufferedReadStream on: stream);				optimizeForLargeStructures;				next ]! !!STONTest class methodsFor: 'utilities'!readFromFileNamed: path	^ path asFileReference		readStreamDo: [ :stream | 			STON reader				on: stream;				next ]! !